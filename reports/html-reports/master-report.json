{"info":{"type":"runner","start":"2021-09-07T11:23:10.043Z","_duration":2821,"cid":"0-0","capabilities":{"acceptInsecureCerts":true,"browserName":"chrome","browserVersion":"93.0.4577.63","chrome":{"chromedriverVersion":"92.0.4515.107 (87a818b10553a07434ea9e2b6dccf3cbe7895134-refs/branch-heads/4515@{#1634})","userDataDir":"/var/folders/mz/jf8rc3lj3t5c5r9lk5z1rrzw0000gp/T/.com.google.Chrome.BanHmm"},"goog:chromeOptions":{"debuggerAddress":"localhost:52729"},"networkConnectionEnabled":false,"pageLoadStrategy":"normal","platformName":"mac os x","proxy":{},"setWindowRect":true,"strictFileInteractability":false,"timeouts":{"implicit":0,"pageLoad":300000,"script":30000},"unhandledPromptBehavior":"dismiss and notify","webauthn:extension:credBlob":true,"webauthn:extension:largeBlob":true,"webauthn:virtualAuthenticators":true,"sessionId":"4db0bc3cdef2df656b9f0614ab9ee086"},"sanitizedCapabilities":"chrome.93_0_4577_63.macosx","config":{"protocol":"http","hostname":"localhost","port":9515,"path":"/","capabilities":{"browserName":"chrome","acceptInsecureCerts":true},"logLevel":"silent","connectionRetryTimeout":120000,"connectionRetryCount":3,"logLevels":{},"strictSSL":true,"requestedCapabilities":{"browserName":"chrome","acceptInsecureCerts":true},"specs":["./test/specs/**/*.js"],"exclude":[],"suites":{"login":["./test/specs/test-login.js"],"alerts":["./test/specs/test-js-alert.js"],"elements":["./test/specs/test-add-elements.js"],"hovers":["./test/specs/test-hovers.js"]},"baseUrl":"https://the-internet.herokuapp.com","bail":0,"waitforInterval":500,"waitforTimeout":10000,"framework":"mocha","reporters":["spec",["allure",{"outputDir":"reports/allure/allure-results"}],["html-nice",{"outputDir":"reports/html-reports/","filename":"report.html","reportTitle":"Test Report Title","showInBrowser":true,"collapseTests":false,"useOnAfterCommandForScreenshot":false}]],"services":["chromedriver"],"execArgv":[],"maxInstances":5,"maxInstancesPerCapability":100,"filesToWatch":[],"onPrepare":[null],"onWorkerStart":[],"before":[],"beforeSession":[],"beforeSuite":[],"beforeHook":[],"beforeTest":[],"beforeCommand":[],"afterCommand":[],"afterTest":[],"afterHook":[],"afterSuite":[],"afterSession":[],"after":[],"onComplete":[null],"onReload":[],"automationProtocol":"webdriver"},"specs":["/Users/amiryamin/Desktop/projects/Mocha-WebdriverIO-Project/test/specs/test-add-elements.js"],"sessionId":"4db0bc3cdef2df656b9f0614ab9ee086","isMultiremote":false,"instanceOptions":{"4db0bc3cdef2df656b9f0614ab9ee086":{"protocol":"http","hostname":"localhost","port":9515,"path":"/","capabilities":{"browserName":"chrome","acceptInsecureCerts":true},"logLevel":"silent","connectionRetryTimeout":120000,"connectionRetryCount":3,"logLevels":{},"strictSSL":true,"requestedCapabilities":{"browserName":"chrome","acceptInsecureCerts":true},"specs":["./test/specs/**/*.js"],"exclude":[],"suites":{"login":["./test/specs/test-login.js"],"alerts":["./test/specs/test-js-alert.js"],"elements":["./test/specs/test-add-elements.js"],"hovers":["./test/specs/test-hovers.js"]},"baseUrl":"https://the-internet.herokuapp.com","bail":0,"waitforInterval":500,"waitforTimeout":10000,"framework":"mocha","reporters":["spec",["allure",{"outputDir":"reports/allure/allure-results"}],["html-nice",{"outputDir":"reports/html-reports/","filename":"report.html","reportTitle":"Test Report Title","showInBrowser":true,"collapseTests":false,"useOnAfterCommandForScreenshot":false}]],"services":["chromedriver"],"execArgv":[],"maxInstances":5,"maxInstancesPerCapability":100,"filesToWatch":[],"onPrepare":[null],"onWorkerStart":[],"before":[],"beforeSession":[],"beforeSuite":[],"beforeHook":[],"beforeTest":[],"beforeCommand":[],"afterCommand":[],"afterTest":[],"afterHook":[],"afterSuite":[],"afterSession":[],"after":[],"onComplete":[null],"onReload":[],"automationProtocol":"webdriver"}},"retry":0,"failures":0,"retries":0,"end":"2021-09-07T11:23:12.864Z"},"metrics":{"passed":11,"skipped":0,"failed":0,"duration":21984,"start":"2021-09-07T11:23:10.048Z","end":"2021-09-07T11:23:32.032Z"},"title":"Master Report","suites":[{"type":"suite:start","start":"2021-09-07T11:23:10.048Z","_duration":2760,"tests":[{"type":"test","start":"2021-09-07T11:23:10.049Z","_duration":2185,"uid":"test-00-0","cid":"0-0","title":"should create a single element","fullTitle":"AddElementsPage.should create a single element","output":[],"retries":0,"parent":"AddElementsPage","state":"passed","events":[],"errorIndex":0,"end":"2021-09-07T11:23:12.234Z"},{"type":"test","start":"2021-09-07T11:23:12.234Z","_duration":298,"uid":"test-00-1","cid":"0-0","title":"should create 2 elements","fullTitle":"AddElementsPage.should create 2 elements","output":[],"retries":0,"parent":"AddElementsPage","state":"passed","events":[],"errorIndex":0,"end":"2021-09-07T11:23:12.532Z"},{"type":"test","start":"2021-09-07T11:23:12.533Z","_duration":267,"uid":"test-00-2","cid":"0-0","title":"should delete single element","fullTitle":"AddElementsPage.should delete single element","output":[],"retries":0,"parent":"AddElementsPage","state":"passed","events":[],"errorIndex":0,"end":"2021-09-07T11:23:12.800Z"}],"hooks":[],"suites":[],"hooksAndTests":[{"type":"test","start":"2021-09-07T11:23:10.049Z","_duration":2185,"uid":"test-00-0","cid":"0-0","title":"should create a single element","fullTitle":"AddElementsPage.should create a single element","output":[{"method":"POST","endpoint":"/session/:sessionId/url","body":{"url":"https://the-internet.herokuapp.com/add_remove_elements/"},"sessionId":"4db0bc3cdef2df656b9f0614ab9ee086","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/url","body":{"url":"https://the-internet.herokuapp.com/add_remove_elements/"},"result":{"value":null},"sessionId":"4db0bc3cdef2df656b9f0614ab9ee086","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//button[@onclick=\"addElement()\"]"},"sessionId":"4db0bc3cdef2df656b9f0614ab9ee086","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//button[@onclick=\"addElement()\"]"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"a11fadf8-81de-4a25-96ab-4199edbb6654"}},"sessionId":"4db0bc3cdef2df656b9f0614ab9ee086","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/a11fadf8-81de-4a25-96ab-4199edbb6654/click","body":{},"sessionId":"4db0bc3cdef2df656b9f0614ab9ee086","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/a11fadf8-81de-4a25-96ab-4199edbb6654/click","body":{},"result":{"value":null},"sessionId":"4db0bc3cdef2df656b9f0614ab9ee086","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"xpath","value":"//div[@id=\"elements\"]//button"},"sessionId":"4db0bc3cdef2df656b9f0614ab9ee086","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"xpath","value":"//div[@id=\"elements\"]//button"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"d2bb53de-b68d-4eb8-8cac-28d41b152d6d"}]},"sessionId":"4db0bc3cdef2df656b9f0614ab9ee086","cid":"0-0","type":"result"}],"retries":0,"parent":"AddElementsPage","state":"passed","events":[],"errorIndex":0,"end":"2021-09-07T11:23:12.234Z"},{"type":"test","start":"2021-09-07T11:23:12.234Z","_duration":298,"uid":"test-00-1","cid":"0-0","title":"should create 2 elements","fullTitle":"AddElementsPage.should create 2 elements","output":[{"method":"POST","endpoint":"/session/:sessionId/url","body":{"url":"https://the-internet.herokuapp.com/add_remove_elements/"},"sessionId":"4db0bc3cdef2df656b9f0614ab9ee086","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/url","body":{"url":"https://the-internet.herokuapp.com/add_remove_elements/"},"result":{"value":null},"sessionId":"4db0bc3cdef2df656b9f0614ab9ee086","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//button[@onclick=\"addElement()\"]"},"sessionId":"4db0bc3cdef2df656b9f0614ab9ee086","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//button[@onclick=\"addElement()\"]"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"a87990b3-edf9-4326-b967-aef2d4232bc4"}},"sessionId":"4db0bc3cdef2df656b9f0614ab9ee086","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/a87990b3-edf9-4326-b967-aef2d4232bc4/click","body":{},"sessionId":"4db0bc3cdef2df656b9f0614ab9ee086","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/a87990b3-edf9-4326-b967-aef2d4232bc4/click","body":{},"result":{"value":null},"sessionId":"4db0bc3cdef2df656b9f0614ab9ee086","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//button[@onclick=\"addElement()\"]"},"sessionId":"4db0bc3cdef2df656b9f0614ab9ee086","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//button[@onclick=\"addElement()\"]"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"a87990b3-edf9-4326-b967-aef2d4232bc4"}},"sessionId":"4db0bc3cdef2df656b9f0614ab9ee086","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/a87990b3-edf9-4326-b967-aef2d4232bc4/click","body":{},"sessionId":"4db0bc3cdef2df656b9f0614ab9ee086","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/a87990b3-edf9-4326-b967-aef2d4232bc4/click","body":{},"result":{"value":null},"sessionId":"4db0bc3cdef2df656b9f0614ab9ee086","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"xpath","value":"//div[@id=\"elements\"]//button"},"sessionId":"4db0bc3cdef2df656b9f0614ab9ee086","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"xpath","value":"//div[@id=\"elements\"]//button"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"557b1997-a852-4322-b390-7ca54abb661b"},{"element-6066-11e4-a52e-4f735466cecf":"87cb9fa5-9dab-4ec2-a0e8-9a3c5590ec6e"}]},"sessionId":"4db0bc3cdef2df656b9f0614ab9ee086","cid":"0-0","type":"result"}],"retries":0,"parent":"AddElementsPage","state":"passed","events":[],"errorIndex":0,"end":"2021-09-07T11:23:12.532Z"},{"type":"test","start":"2021-09-07T11:23:12.533Z","_duration":267,"uid":"test-00-2","cid":"0-0","title":"should delete single element","fullTitle":"AddElementsPage.should delete single element","output":[{"method":"POST","endpoint":"/session/:sessionId/url","body":{"url":"https://the-internet.herokuapp.com/add_remove_elements/"},"sessionId":"4db0bc3cdef2df656b9f0614ab9ee086","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/url","body":{"url":"https://the-internet.herokuapp.com/add_remove_elements/"},"result":{"value":null},"sessionId":"4db0bc3cdef2df656b9f0614ab9ee086","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//button[@onclick=\"addElement()\"]"},"sessionId":"4db0bc3cdef2df656b9f0614ab9ee086","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//button[@onclick=\"addElement()\"]"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"0281612c-cac9-412e-be5e-e4224c242f26"}},"sessionId":"4db0bc3cdef2df656b9f0614ab9ee086","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/0281612c-cac9-412e-be5e-e4224c242f26/click","body":{},"sessionId":"4db0bc3cdef2df656b9f0614ab9ee086","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/0281612c-cac9-412e-be5e-e4224c242f26/click","body":{},"result":{"value":null},"sessionId":"4db0bc3cdef2df656b9f0614ab9ee086","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"xpath","value":"//div[@id=\"elements\"]//button"},"sessionId":"4db0bc3cdef2df656b9f0614ab9ee086","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"xpath","value":"//div[@id=\"elements\"]//button"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"fe8ed454-95ff-49a0-88bd-d061a51f4fb3"}]},"sessionId":"4db0bc3cdef2df656b9f0614ab9ee086","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"xpath","value":"//div[@id=\"elements\"]//button"},"sessionId":"4db0bc3cdef2df656b9f0614ab9ee086","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"xpath","value":"//div[@id=\"elements\"]//button"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"fe8ed454-95ff-49a0-88bd-d061a51f4fb3"}]},"sessionId":"4db0bc3cdef2df656b9f0614ab9ee086","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/fe8ed454-95ff-49a0-88bd-d061a51f4fb3/click","body":{},"sessionId":"4db0bc3cdef2df656b9f0614ab9ee086","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/fe8ed454-95ff-49a0-88bd-d061a51f4fb3/click","body":{},"result":{"value":null},"sessionId":"4db0bc3cdef2df656b9f0614ab9ee086","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"xpath","value":"//div[@id=\"elements\"]//button"},"sessionId":"4db0bc3cdef2df656b9f0614ab9ee086","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"xpath","value":"//div[@id=\"elements\"]//button"},"result":{"value":[]},"sessionId":"4db0bc3cdef2df656b9f0614ab9ee086","cid":"0-0","type":"result"},{"method":"DELETE","endpoint":"/session/:sessionId","body":{},"sessionId":"4db0bc3cdef2df656b9f0614ab9ee086","cid":"0-0","type":"command"},{"method":"DELETE","endpoint":"/session/:sessionId","body":{},"result":{"value":null},"sessionId":"4db0bc3cdef2df656b9f0614ab9ee086","cid":"0-0","type":"result"}],"retries":0,"parent":"AddElementsPage","state":"passed","events":[],"errorIndex":0,"end":"2021-09-07T11:23:12.800Z"}],"uid":"suite-0-0","cid":"0-0","file":"/Users/amiryamin/Desktop/projects/Mocha-WebdriverIO-Project/test/specs/test-add-elements.js","title":"AddElementsPage","fullTitle":"AddElementsPage","parent":"","end":"2021-09-07T11:23:12.808Z"},{"type":"suite:start","start":"2021-09-07T11:23:15.257Z","_duration":2937,"tests":[{"type":"test","start":"2021-09-07T11:23:15.258Z","_duration":2406,"uid":"test-00-0","cid":"0-1","title":"should show expected figure info on hover","fullTitle":"HoversPage.should show expected figure info on hover","output":[],"retries":0,"parent":"HoversPage","state":"passed","events":[],"errorIndex":0,"end":"2021-09-07T11:23:17.664Z"},{"type":"test","start":"2021-09-07T11:23:17.664Z","_duration":519,"uid":"test-00-1","cid":"0-1","title":"should navigate to expected profile","fullTitle":"HoversPage.should navigate to expected profile","output":[],"retries":0,"parent":"HoversPage","state":"passed","events":[],"errorIndex":0,"end":"2021-09-07T11:23:18.183Z"}],"hooks":[],"suites":[],"hooksAndTests":[{"type":"test","start":"2021-09-07T11:23:15.258Z","_duration":2406,"uid":"test-00-0","cid":"0-1","title":"should show expected figure info on hover","fullTitle":"HoversPage.should show expected figure info on hover","output":[{"method":"POST","endpoint":"/session/:sessionId/url","body":{"url":"https://the-internet.herokuapp.com/hovers"},"sessionId":"14674f263bd41a4ff2f03a5feb807afc","cid":"0-1","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/url","body":{"url":"https://the-internet.herokuapp.com/hovers"},"result":{"value":null},"sessionId":"14674f263bd41a4ff2f03a5feb807afc","cid":"0-1","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"xpath","value":"//div[@class=\"figure\"]/img"},"sessionId":"14674f263bd41a4ff2f03a5feb807afc","cid":"0-1","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"xpath","value":"//div[@class=\"figure\"]/img"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"b19c9e34-36d8-4fe4-baef-84484eee85b2"},{"element-6066-11e4-a52e-4f735466cecf":"793bc511-0616-4653-be9c-72dace44a2c8"},{"element-6066-11e4-a52e-4f735466cecf":"8dd9f3d6-5025-4dc8-b484-121f69ff2831"}]},"sessionId":"14674f263bd41a4ff2f03a5feb807afc","cid":"0-1","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"b19c9e34-36d8-4fe4-baef-84484eee85b2","ELEMENT":"b19c9e34-36d8-4fe4-baef-84484eee85b2"}]},"sessionId":"14674f263bd41a4ff2f03a5feb807afc","cid":"0-1","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"b19c9e34-36d8-4fe4-baef-84484eee85b2","ELEMENT":"b19c9e34-36d8-4fe4-baef-84484eee85b2"}]},"result":{"value":true},"sessionId":"14674f263bd41a4ff2f03a5feb807afc","cid":"0-1","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"xpath","value":"//div[@class=\"figure\"]/img"},"sessionId":"14674f263bd41a4ff2f03a5feb807afc","cid":"0-1","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"xpath","value":"//div[@class=\"figure\"]/img"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"b19c9e34-36d8-4fe4-baef-84484eee85b2"},{"element-6066-11e4-a52e-4f735466cecf":"793bc511-0616-4653-be9c-72dace44a2c8"},{"element-6066-11e4-a52e-4f735466cecf":"8dd9f3d6-5025-4dc8-b484-121f69ff2831"}]},"sessionId":"14674f263bd41a4ff2f03a5feb807afc","cid":"0-1","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/b19c9e34-36d8-4fe4-baef-84484eee85b2/rect","body":{},"sessionId":"14674f263bd41a4ff2f03a5feb807afc","cid":"0-1","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/b19c9e34-36d8-4fe4-baef-84484eee85b2/rect","body":{},"result":{"value":{"height":160,"width":160,"x":115,"y":132.890625}},"sessionId":"14674f263bd41a4ff2f03a5feb807afc","cid":"0-1","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function () {\n        return { scrollX: this.pageXOffset, scrollY: this.pageYOffset };\n    }).apply(null, arguments)","args":[]},"sessionId":"14674f263bd41a4ff2f03a5feb807afc","cid":"0-1","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function () {\n        return { scrollX: this.pageXOffset, scrollY: this.pageYOffset };\n    }).apply(null, arguments)","args":[]},"result":{"value":{"scrollX":0,"scrollY":0}},"sessionId":"14674f263bd41a4ff2f03a5feb807afc","cid":"0-1","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/actions","body":{"actions":[{"type":"pointer","id":"finger1","parameters":{"pointerType":"mouse"},"actions":[{"type":"pointerMove","duration":0,"x":195,"y":212}]}]},"sessionId":"14674f263bd41a4ff2f03a5feb807afc","cid":"0-1","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/actions","body":{"actions":[{"type":"pointer","id":"finger1","parameters":{"pointerType":"mouse"},"actions":[{"type":"pointerMove","duration":0,"x":195,"y":212}]}]},"result":{"value":null},"sessionId":"14674f263bd41a4ff2f03a5feb807afc","cid":"0-1","type":"result"},{"method":"DELETE","endpoint":"/session/:sessionId/actions","body":{},"sessionId":"14674f263bd41a4ff2f03a5feb807afc","cid":"0-1","type":"command"},{"method":"DELETE","endpoint":"/session/:sessionId/actions","body":{},"result":{"value":null},"sessionId":"14674f263bd41a4ff2f03a5feb807afc","cid":"0-1","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"xpath","value":"//div[@class=\"figcaption\"]/h5"},"sessionId":"14674f263bd41a4ff2f03a5feb807afc","cid":"0-1","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"xpath","value":"//div[@class=\"figcaption\"]/h5"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"bbc366df-3171-44e1-9533-b665af24a828"},{"element-6066-11e4-a52e-4f735466cecf":"7b5e476f-c170-45b5-bcbf-56dde4e81550"},{"element-6066-11e4-a52e-4f735466cecf":"94f039ba-b6df-412e-bbaf-afdbfeff02d4"}]},"sessionId":"14674f263bd41a4ff2f03a5feb807afc","cid":"0-1","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"bbc366df-3171-44e1-9533-b665af24a828","ELEMENT":"bbc366df-3171-44e1-9533-b665af24a828"}]},"sessionId":"14674f263bd41a4ff2f03a5feb807afc","cid":"0-1","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"bbc366df-3171-44e1-9533-b665af24a828","ELEMENT":"bbc366df-3171-44e1-9533-b665af24a828"}]},"result":{"value":true},"sessionId":"14674f263bd41a4ff2f03a5feb807afc","cid":"0-1","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"xpath","value":"//div[@class=\"figcaption\"]/h5"},"sessionId":"14674f263bd41a4ff2f03a5feb807afc","cid":"0-1","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"xpath","value":"//div[@class=\"figcaption\"]/h5"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"bbc366df-3171-44e1-9533-b665af24a828"},{"element-6066-11e4-a52e-4f735466cecf":"7b5e476f-c170-45b5-bcbf-56dde4e81550"},{"element-6066-11e4-a52e-4f735466cecf":"94f039ba-b6df-412e-bbaf-afdbfeff02d4"}]},"sessionId":"14674f263bd41a4ff2f03a5feb807afc","cid":"0-1","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/bbc366df-3171-44e1-9533-b665af24a828/text","body":{},"sessionId":"14674f263bd41a4ff2f03a5feb807afc","cid":"0-1","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/bbc366df-3171-44e1-9533-b665af24a828/text","body":{},"result":{"value":"name: user1"},"sessionId":"14674f263bd41a4ff2f03a5feb807afc","cid":"0-1","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"xpath","value":"//div[@class=\"figcaption\"]/a"},"sessionId":"14674f263bd41a4ff2f03a5feb807afc","cid":"0-1","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"xpath","value":"//div[@class=\"figcaption\"]/a"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"3a494692-8400-4bc0-9417-2a8b3d1376ec"},{"element-6066-11e4-a52e-4f735466cecf":"d387a0c2-0bda-46bf-b99b-e0cf56654d05"},{"element-6066-11e4-a52e-4f735466cecf":"bec306f7-c59b-43f4-8e49-1c8a2c685510"}]},"sessionId":"14674f263bd41a4ff2f03a5feb807afc","cid":"0-1","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/3a494692-8400-4bc0-9417-2a8b3d1376ec/attribute/href","body":{},"sessionId":"14674f263bd41a4ff2f03a5feb807afc","cid":"0-1","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/3a494692-8400-4bc0-9417-2a8b3d1376ec/attribute/href","body":{},"result":{"value":"/users/1"},"sessionId":"14674f263bd41a4ff2f03a5feb807afc","cid":"0-1","type":"result"}],"retries":0,"parent":"HoversPage","state":"passed","events":[],"errorIndex":0,"end":"2021-09-07T11:23:17.664Z"},{"type":"test","start":"2021-09-07T11:23:17.664Z","_duration":519,"uid":"test-00-1","cid":"0-1","title":"should navigate to expected profile","fullTitle":"HoversPage.should navigate to expected profile","output":[{"method":"POST","endpoint":"/session/:sessionId/url","body":{"url":"https://the-internet.herokuapp.com/hovers"},"sessionId":"14674f263bd41a4ff2f03a5feb807afc","cid":"0-1","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/url","body":{"url":"https://the-internet.herokuapp.com/hovers"},"result":{"value":null},"sessionId":"14674f263bd41a4ff2f03a5feb807afc","cid":"0-1","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"xpath","value":"//div[@class=\"figure\"]/img"},"sessionId":"14674f263bd41a4ff2f03a5feb807afc","cid":"0-1","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"xpath","value":"//div[@class=\"figure\"]/img"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"e71c8e84-af9e-4a3b-bcf7-1f092c876865"},{"element-6066-11e4-a52e-4f735466cecf":"d7653dc9-1c41-4399-9217-cd9435654650"},{"element-6066-11e4-a52e-4f735466cecf":"0f19aeaa-a2f9-4311-b33a-a4196ba2d391"}]},"sessionId":"14674f263bd41a4ff2f03a5feb807afc","cid":"0-1","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"0f19aeaa-a2f9-4311-b33a-a4196ba2d391","ELEMENT":"0f19aeaa-a2f9-4311-b33a-a4196ba2d391"}]},"sessionId":"14674f263bd41a4ff2f03a5feb807afc","cid":"0-1","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"0f19aeaa-a2f9-4311-b33a-a4196ba2d391","ELEMENT":"0f19aeaa-a2f9-4311-b33a-a4196ba2d391"}]},"result":{"value":true},"sessionId":"14674f263bd41a4ff2f03a5feb807afc","cid":"0-1","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"xpath","value":"//div[@class=\"figure\"]/img"},"sessionId":"14674f263bd41a4ff2f03a5feb807afc","cid":"0-1","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"xpath","value":"//div[@class=\"figure\"]/img"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"e71c8e84-af9e-4a3b-bcf7-1f092c876865"},{"element-6066-11e4-a52e-4f735466cecf":"d7653dc9-1c41-4399-9217-cd9435654650"},{"element-6066-11e4-a52e-4f735466cecf":"0f19aeaa-a2f9-4311-b33a-a4196ba2d391"}]},"sessionId":"14674f263bd41a4ff2f03a5feb807afc","cid":"0-1","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/0f19aeaa-a2f9-4311-b33a-a4196ba2d391/rect","body":{},"sessionId":"14674f263bd41a4ff2f03a5feb807afc","cid":"0-1","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/0f19aeaa-a2f9-4311-b33a-a4196ba2d391/rect","body":{},"result":{"value":{"height":160,"width":160,"x":475,"y":132.890625}},"sessionId":"14674f263bd41a4ff2f03a5feb807afc","cid":"0-1","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function () {\n        return { scrollX: this.pageXOffset, scrollY: this.pageYOffset };\n    }).apply(null, arguments)","args":[]},"sessionId":"14674f263bd41a4ff2f03a5feb807afc","cid":"0-1","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function () {\n        return { scrollX: this.pageXOffset, scrollY: this.pageYOffset };\n    }).apply(null, arguments)","args":[]},"result":{"value":{"scrollX":0,"scrollY":0}},"sessionId":"14674f263bd41a4ff2f03a5feb807afc","cid":"0-1","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/actions","body":{"actions":[{"type":"pointer","id":"finger1","parameters":{"pointerType":"mouse"},"actions":[{"type":"pointerMove","duration":0,"x":555,"y":212}]}]},"sessionId":"14674f263bd41a4ff2f03a5feb807afc","cid":"0-1","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/actions","body":{"actions":[{"type":"pointer","id":"finger1","parameters":{"pointerType":"mouse"},"actions":[{"type":"pointerMove","duration":0,"x":555,"y":212}]}]},"result":{"value":null},"sessionId":"14674f263bd41a4ff2f03a5feb807afc","cid":"0-1","type":"result"},{"method":"DELETE","endpoint":"/session/:sessionId/actions","body":{},"sessionId":"14674f263bd41a4ff2f03a5feb807afc","cid":"0-1","type":"command"},{"method":"DELETE","endpoint":"/session/:sessionId/actions","body":{},"result":{"value":null},"sessionId":"14674f263bd41a4ff2f03a5feb807afc","cid":"0-1","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"xpath","value":"//div[@class=\"figcaption\"]/h5"},"sessionId":"14674f263bd41a4ff2f03a5feb807afc","cid":"0-1","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"xpath","value":"//div[@class=\"figcaption\"]/h5"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"0b57b36b-e2a4-42b4-a32c-18c2ffb1b920"},{"element-6066-11e4-a52e-4f735466cecf":"2397de3a-ee73-4987-80d1-6a9a1f14acc1"},{"element-6066-11e4-a52e-4f735466cecf":"51807ad8-4e11-4e2b-8121-a26fc72a160d"}]},"sessionId":"14674f263bd41a4ff2f03a5feb807afc","cid":"0-1","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"51807ad8-4e11-4e2b-8121-a26fc72a160d","ELEMENT":"51807ad8-4e11-4e2b-8121-a26fc72a160d"}]},"sessionId":"14674f263bd41a4ff2f03a5feb807afc","cid":"0-1","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"51807ad8-4e11-4e2b-8121-a26fc72a160d","ELEMENT":"51807ad8-4e11-4e2b-8121-a26fc72a160d"}]},"result":{"value":true},"sessionId":"14674f263bd41a4ff2f03a5feb807afc","cid":"0-1","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"xpath","value":"//div[@class=\"figcaption\"]/h5"},"sessionId":"14674f263bd41a4ff2f03a5feb807afc","cid":"0-1","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"xpath","value":"//div[@class=\"figcaption\"]/h5"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"0b57b36b-e2a4-42b4-a32c-18c2ffb1b920"},{"element-6066-11e4-a52e-4f735466cecf":"2397de3a-ee73-4987-80d1-6a9a1f14acc1"},{"element-6066-11e4-a52e-4f735466cecf":"51807ad8-4e11-4e2b-8121-a26fc72a160d"}]},"sessionId":"14674f263bd41a4ff2f03a5feb807afc","cid":"0-1","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/51807ad8-4e11-4e2b-8121-a26fc72a160d/text","body":{},"sessionId":"14674f263bd41a4ff2f03a5feb807afc","cid":"0-1","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/51807ad8-4e11-4e2b-8121-a26fc72a160d/text","body":{},"result":{"value":"name: user3"},"sessionId":"14674f263bd41a4ff2f03a5feb807afc","cid":"0-1","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"xpath","value":"//div[@class=\"figcaption\"]/a"},"sessionId":"14674f263bd41a4ff2f03a5feb807afc","cid":"0-1","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"xpath","value":"//div[@class=\"figcaption\"]/a"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"6a832671-d9ea-4a15-b9e7-412f8376b362"},{"element-6066-11e4-a52e-4f735466cecf":"40dbee13-9ab4-418d-a4f2-882588e3d317"},{"element-6066-11e4-a52e-4f735466cecf":"2dca22ff-befe-41fb-9d67-35088fb5bb88"}]},"sessionId":"14674f263bd41a4ff2f03a5feb807afc","cid":"0-1","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/2dca22ff-befe-41fb-9d67-35088fb5bb88/attribute/href","body":{},"sessionId":"14674f263bd41a4ff2f03a5feb807afc","cid":"0-1","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/2dca22ff-befe-41fb-9d67-35088fb5bb88/attribute/href","body":{},"result":{"value":"/users/3"},"sessionId":"14674f263bd41a4ff2f03a5feb807afc","cid":"0-1","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"xpath","value":"//div[@class=\"figcaption\"]/a"},"sessionId":"14674f263bd41a4ff2f03a5feb807afc","cid":"0-1","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"xpath","value":"//div[@class=\"figcaption\"]/a"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"6a832671-d9ea-4a15-b9e7-412f8376b362"},{"element-6066-11e4-a52e-4f735466cecf":"40dbee13-9ab4-418d-a4f2-882588e3d317"},{"element-6066-11e4-a52e-4f735466cecf":"2dca22ff-befe-41fb-9d67-35088fb5bb88"}]},"sessionId":"14674f263bd41a4ff2f03a5feb807afc","cid":"0-1","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/2dca22ff-befe-41fb-9d67-35088fb5bb88/click","body":{},"sessionId":"14674f263bd41a4ff2f03a5feb807afc","cid":"0-1","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/2dca22ff-befe-41fb-9d67-35088fb5bb88/click","body":{},"result":{"value":null},"sessionId":"14674f263bd41a4ff2f03a5feb807afc","cid":"0-1","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"sessionId":"14674f263bd41a4ff2f03a5feb807afc","cid":"0-1","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"result":{"value":"https://the-internet.herokuapp.com/users/3"},"sessionId":"14674f263bd41a4ff2f03a5feb807afc","cid":"0-1","type":"result"},{"method":"DELETE","endpoint":"/session/:sessionId","body":{},"sessionId":"14674f263bd41a4ff2f03a5feb807afc","cid":"0-1","type":"command"},{"method":"DELETE","endpoint":"/session/:sessionId","body":{},"result":{"value":null},"sessionId":"14674f263bd41a4ff2f03a5feb807afc","cid":"0-1","type":"result"}],"retries":0,"parent":"HoversPage","state":"passed","events":[],"errorIndex":0,"end":"2021-09-07T11:23:18.183Z"}],"uid":"suite-0-0","cid":"0-1","file":"/Users/amiryamin/Desktop/projects/Mocha-WebdriverIO-Project/test/specs/test-hovers.js","title":"HoversPage","fullTitle":"HoversPage","parent":"","end":"2021-09-07T11:23:18.194Z"},{"type":"suite:start","start":"2021-09-07T11:23:20.499Z","_duration":3680,"tests":[{"type":"test","start":"2021-09-07T11:23:20.499Z","_duration":2679,"uid":"test-00-0","cid":"0-2","title":"should show js single alert","fullTitle":"JavaScriptAlertPage.should show js single alert","output":[],"retries":0,"parent":"JavaScriptAlertPage","state":"passed","events":[],"errorIndex":0,"end":"2021-09-07T11:23:23.178Z"},{"type":"test","start":"2021-09-07T11:23:23.179Z","_duration":337,"uid":"test-00-1","cid":"0-2","title":"should cancel js confirm alert","fullTitle":"JavaScriptAlertPage.should cancel js confirm alert","output":[],"retries":0,"parent":"JavaScriptAlertPage","state":"passed","events":[],"errorIndex":0,"end":"2021-09-07T11:23:23.516Z"},{"type":"test","start":"2021-09-07T11:23:23.516Z","_duration":653,"uid":"test-00-2","cid":"0-2","title":"should display js prompt alert input","fullTitle":"JavaScriptAlertPage.should display js prompt alert input","output":[],"retries":0,"parent":"JavaScriptAlertPage","state":"passed","events":[],"errorIndex":0,"end":"2021-09-07T11:23:24.169Z"}],"hooks":[],"suites":[],"hooksAndTests":[{"type":"test","start":"2021-09-07T11:23:20.499Z","_duration":2679,"uid":"test-00-0","cid":"0-2","title":"should show js single alert","fullTitle":"JavaScriptAlertPage.should show js single alert","output":[{"method":"POST","endpoint":"/session/:sessionId/url","body":{"url":"https://the-internet.herokuapp.com/javascript_alerts"},"sessionId":"24f4607ec9bc26a731949ad3ce62fe67","cid":"0-2","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/url","body":{"url":"https://the-internet.herokuapp.com/javascript_alerts"},"result":{"value":null},"sessionId":"24f4607ec9bc26a731949ad3ce62fe67","cid":"0-2","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//button[@onclick=\"jsConfirm()\"]"},"sessionId":"24f4607ec9bc26a731949ad3ce62fe67","cid":"0-2","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//button[@onclick=\"jsPrompt()\"]"},"sessionId":"24f4607ec9bc26a731949ad3ce62fe67","cid":"0-2","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//button[@onclick=\"jsAlert()\"]"},"sessionId":"24f4607ec9bc26a731949ad3ce62fe67","cid":"0-2","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//button[@onclick=\"jsConfirm()\"]"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"29ee8dbd-3aca-4dc5-93bb-921bed5deb8c"}},"sessionId":"24f4607ec9bc26a731949ad3ce62fe67","cid":"0-2","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//button[@onclick=\"jsPrompt()\"]"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"2c92709c-9545-4821-8f98-c4936937c64d"}},"sessionId":"24f4607ec9bc26a731949ad3ce62fe67","cid":"0-2","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//button[@onclick=\"jsAlert()\"]"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f3b9d6fb-b679-49d6-b12e-92dafbb8bf87"}},"sessionId":"24f4607ec9bc26a731949ad3ce62fe67","cid":"0-2","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"f3b9d6fb-b679-49d6-b12e-92dafbb8bf87","ELEMENT":"f3b9d6fb-b679-49d6-b12e-92dafbb8bf87"}]},"sessionId":"24f4607ec9bc26a731949ad3ce62fe67","cid":"0-2","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"f3b9d6fb-b679-49d6-b12e-92dafbb8bf87","ELEMENT":"f3b9d6fb-b679-49d6-b12e-92dafbb8bf87"}]},"result":{"value":true},"sessionId":"24f4607ec9bc26a731949ad3ce62fe67","cid":"0-2","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/f3b9d6fb-b679-49d6-b12e-92dafbb8bf87/click","body":{},"sessionId":"24f4607ec9bc26a731949ad3ce62fe67","cid":"0-2","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/f3b9d6fb-b679-49d6-b12e-92dafbb8bf87/click","body":{},"result":{"value":null},"sessionId":"24f4607ec9bc26a731949ad3ce62fe67","cid":"0-2","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/alert/text","body":{},"sessionId":"24f4607ec9bc26a731949ad3ce62fe67","cid":"0-2","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/alert/text","body":{},"result":{"value":"I am a JS Alert"},"sessionId":"24f4607ec9bc26a731949ad3ce62fe67","cid":"0-2","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/alert/accept","body":{},"sessionId":"24f4607ec9bc26a731949ad3ce62fe67","cid":"0-2","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/alert/accept","body":{},"result":{"value":null},"sessionId":"24f4607ec9bc26a731949ad3ce62fe67","cid":"0-2","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/alert","body":{},"sessionId":"24f4607ec9bc26a731949ad3ce62fe67","cid":"0-2","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/alert","body":{},"result":{"value":false},"sessionId":"24f4607ec9bc26a731949ad3ce62fe67","cid":"0-2","type":"result"}],"retries":0,"parent":"JavaScriptAlertPage","state":"passed","events":[],"errorIndex":0,"end":"2021-09-07T11:23:23.178Z"},{"type":"test","start":"2021-09-07T11:23:23.179Z","_duration":337,"uid":"test-00-1","cid":"0-2","title":"should cancel js confirm alert","fullTitle":"JavaScriptAlertPage.should cancel js confirm alert","output":[{"method":"POST","endpoint":"/session/:sessionId/url","body":{"url":"https://the-internet.herokuapp.com/javascript_alerts"},"sessionId":"24f4607ec9bc26a731949ad3ce62fe67","cid":"0-2","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/url","body":{"url":"https://the-internet.herokuapp.com/javascript_alerts"},"result":{"value":null},"sessionId":"24f4607ec9bc26a731949ad3ce62fe67","cid":"0-2","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//button[@onclick=\"jsConfirm()\"]"},"sessionId":"24f4607ec9bc26a731949ad3ce62fe67","cid":"0-2","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//button[@onclick=\"jsPrompt()\"]"},"sessionId":"24f4607ec9bc26a731949ad3ce62fe67","cid":"0-2","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//button[@onclick=\"jsAlert()\"]"},"sessionId":"24f4607ec9bc26a731949ad3ce62fe67","cid":"0-2","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//button[@onclick=\"jsConfirm()\"]"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"45de5757-3845-42e0-9ea3-49f1762bcf05"}},"sessionId":"24f4607ec9bc26a731949ad3ce62fe67","cid":"0-2","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"45de5757-3845-42e0-9ea3-49f1762bcf05","ELEMENT":"45de5757-3845-42e0-9ea3-49f1762bcf05"}]},"sessionId":"24f4607ec9bc26a731949ad3ce62fe67","cid":"0-2","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//button[@onclick=\"jsPrompt()\"]"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"e6ba5320-d151-4a1e-8cae-d4da8707c4e9"}},"sessionId":"24f4607ec9bc26a731949ad3ce62fe67","cid":"0-2","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//button[@onclick=\"jsAlert()\"]"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"d93f8356-c4dc-428a-8c51-ab5429c97f80"}},"sessionId":"24f4607ec9bc26a731949ad3ce62fe67","cid":"0-2","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"45de5757-3845-42e0-9ea3-49f1762bcf05","ELEMENT":"45de5757-3845-42e0-9ea3-49f1762bcf05"}]},"result":{"value":true},"sessionId":"24f4607ec9bc26a731949ad3ce62fe67","cid":"0-2","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/45de5757-3845-42e0-9ea3-49f1762bcf05/click","body":{},"sessionId":"24f4607ec9bc26a731949ad3ce62fe67","cid":"0-2","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/45de5757-3845-42e0-9ea3-49f1762bcf05/click","body":{},"result":{"value":null},"sessionId":"24f4607ec9bc26a731949ad3ce62fe67","cid":"0-2","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/alert/text","body":{},"sessionId":"24f4607ec9bc26a731949ad3ce62fe67","cid":"0-2","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/alert/text","body":{},"result":{"value":"I am a JS Confirm"},"sessionId":"24f4607ec9bc26a731949ad3ce62fe67","cid":"0-2","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/alert/dismiss","body":{},"sessionId":"24f4607ec9bc26a731949ad3ce62fe67","cid":"0-2","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/alert/dismiss","body":{},"result":{"value":null},"sessionId":"24f4607ec9bc26a731949ad3ce62fe67","cid":"0-2","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/alert","body":{},"sessionId":"24f4607ec9bc26a731949ad3ce62fe67","cid":"0-2","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/alert","body":{},"result":{"value":false},"sessionId":"24f4607ec9bc26a731949ad3ce62fe67","cid":"0-2","type":"result"}],"retries":0,"parent":"JavaScriptAlertPage","state":"passed","events":[],"errorIndex":0,"end":"2021-09-07T11:23:23.516Z"},{"type":"test","start":"2021-09-07T11:23:23.516Z","_duration":653,"uid":"test-00-2","cid":"0-2","title":"should display js prompt alert input","fullTitle":"JavaScriptAlertPage.should display js prompt alert input","output":[{"method":"POST","endpoint":"/session/:sessionId/url","body":{"url":"https://the-internet.herokuapp.com/javascript_alerts"},"sessionId":"24f4607ec9bc26a731949ad3ce62fe67","cid":"0-2","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/url","body":{"url":"https://the-internet.herokuapp.com/javascript_alerts"},"result":{"value":null},"sessionId":"24f4607ec9bc26a731949ad3ce62fe67","cid":"0-2","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//button[@onclick=\"jsConfirm()\"]"},"sessionId":"24f4607ec9bc26a731949ad3ce62fe67","cid":"0-2","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//button[@onclick=\"jsPrompt()\"]"},"sessionId":"24f4607ec9bc26a731949ad3ce62fe67","cid":"0-2","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//button[@onclick=\"jsAlert()\"]"},"sessionId":"24f4607ec9bc26a731949ad3ce62fe67","cid":"0-2","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//button[@onclick=\"jsConfirm()\"]"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"493ca572-605a-465e-affc-1e17496c88e3"}},"sessionId":"24f4607ec9bc26a731949ad3ce62fe67","cid":"0-2","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//button[@onclick=\"jsPrompt()\"]"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"a52ff010-dc33-445f-b83e-04b7a5f67641"}},"sessionId":"24f4607ec9bc26a731949ad3ce62fe67","cid":"0-2","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"a52ff010-dc33-445f-b83e-04b7a5f67641","ELEMENT":"a52ff010-dc33-445f-b83e-04b7a5f67641"}]},"sessionId":"24f4607ec9bc26a731949ad3ce62fe67","cid":"0-2","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//button[@onclick=\"jsAlert()\"]"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"8f65a0f6-80cf-48a4-9b51-1fc27d52e882"}},"sessionId":"24f4607ec9bc26a731949ad3ce62fe67","cid":"0-2","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"a52ff010-dc33-445f-b83e-04b7a5f67641","ELEMENT":"a52ff010-dc33-445f-b83e-04b7a5f67641"}]},"result":{"value":true},"sessionId":"24f4607ec9bc26a731949ad3ce62fe67","cid":"0-2","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/a52ff010-dc33-445f-b83e-04b7a5f67641/click","body":{},"sessionId":"24f4607ec9bc26a731949ad3ce62fe67","cid":"0-2","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/a52ff010-dc33-445f-b83e-04b7a5f67641/click","body":{},"result":{"value":null},"sessionId":"24f4607ec9bc26a731949ad3ce62fe67","cid":"0-2","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/alert/text","body":{},"sessionId":"24f4607ec9bc26a731949ad3ce62fe67","cid":"0-2","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/alert/text","body":{},"result":{"value":"I am a JS prompt"},"sessionId":"24f4607ec9bc26a731949ad3ce62fe67","cid":"0-2","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/alert/text","body":{"text":"Hello Wo1rld!"},"sessionId":"24f4607ec9bc26a731949ad3ce62fe67","cid":"0-2","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/alert/text","body":{"text":"Hello Wo1rld!"},"result":{"value":null},"sessionId":"24f4607ec9bc26a731949ad3ce62fe67","cid":"0-2","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/alert/accept","body":{},"sessionId":"24f4607ec9bc26a731949ad3ce62fe67","cid":"0-2","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/alert/accept","body":{},"result":{"value":null},"sessionId":"24f4607ec9bc26a731949ad3ce62fe67","cid":"0-2","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#result"},"sessionId":"24f4607ec9bc26a731949ad3ce62fe67","cid":"0-2","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#result"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"8aa9debd-4aa0-4fd5-a59b-7cfacbcef2f5"}},"sessionId":"24f4607ec9bc26a731949ad3ce62fe67","cid":"0-2","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/8aa9debd-4aa0-4fd5-a59b-7cfacbcef2f5/text","body":{},"sessionId":"24f4607ec9bc26a731949ad3ce62fe67","cid":"0-2","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/8aa9debd-4aa0-4fd5-a59b-7cfacbcef2f5/text","body":{},"result":{"value":"You entered: Hello Wo1rld!"},"sessionId":"24f4607ec9bc26a731949ad3ce62fe67","cid":"0-2","type":"result"},{"method":"DELETE","endpoint":"/session/:sessionId","body":{},"sessionId":"24f4607ec9bc26a731949ad3ce62fe67","cid":"0-2","type":"command"},{"method":"DELETE","endpoint":"/session/:sessionId","body":{},"result":{"value":null},"sessionId":"24f4607ec9bc26a731949ad3ce62fe67","cid":"0-2","type":"result"}],"retries":0,"parent":"JavaScriptAlertPage","state":"passed","events":[],"errorIndex":0,"end":"2021-09-07T11:23:24.169Z"}],"uid":"suite-0-0","cid":"0-2","file":"/Users/amiryamin/Desktop/projects/Mocha-WebdriverIO-Project/test/specs/test-js-alert.js","title":"JavaScriptAlertPage","fullTitle":"JavaScriptAlertPage","parent":"","end":"2021-09-07T11:23:24.179Z"},{"type":"suite:start","start":"2021-09-07T11:23:26.441Z","_duration":5191,"tests":[{"type":"test","start":"2021-09-07T11:23:26.442Z","_duration":3934,"uid":"test-00-0","cid":"0-3","title":"should allow user login secure area","fullTitle":"LoginPage.should allow user login secure area","output":[],"retries":0,"parent":"LoginPage","state":"passed","events":[],"errorIndex":0,"end":"2021-09-07T11:23:30.376Z"},{"type":"test","start":"2021-09-07T11:23:30.377Z","_duration":1242,"uid":"test-00-1","cid":"0-3","title":"should allow user logout","fullTitle":"LoginPage.should allow user logout","output":[],"retries":0,"parent":"LoginPage","state":"passed","events":[],"errorIndex":0,"end":"2021-09-07T11:23:31.619Z"}],"hooks":[],"suites":[],"hooksAndTests":[{"type":"test","start":"2021-09-07T11:23:26.442Z","_duration":3934,"uid":"test-00-0","cid":"0-3","title":"should allow user login secure area","fullTitle":"LoginPage.should allow user login secure area","output":[{"method":"POST","endpoint":"/session/:sessionId/url","body":{"url":"https://the-internet.herokuapp.com/login"},"sessionId":"837d0446e382f7a49dd628293066bf67","cid":"0-3","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/url","body":{"url":"https://the-internet.herokuapp.com/login"},"result":{"value":null},"sessionId":"837d0446e382f7a49dd628293066bf67","cid":"0-3","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#username"},"sessionId":"837d0446e382f7a49dd628293066bf67","cid":"0-3","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#username"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"b5f16b8d-db49-479c-893b-ec3305f80c97"}},"sessionId":"837d0446e382f7a49dd628293066bf67","cid":"0-3","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"b5f16b8d-db49-479c-893b-ec3305f80c97","ELEMENT":"b5f16b8d-db49-479c-893b-ec3305f80c97"}]},"sessionId":"837d0446e382f7a49dd628293066bf67","cid":"0-3","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"b5f16b8d-db49-479c-893b-ec3305f80c97","ELEMENT":"b5f16b8d-db49-479c-893b-ec3305f80c97"}]},"result":{"value":true},"sessionId":"837d0446e382f7a49dd628293066bf67","cid":"0-3","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#username"},"sessionId":"837d0446e382f7a49dd628293066bf67","cid":"0-3","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#username"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"b5f16b8d-db49-479c-893b-ec3305f80c97"}},"sessionId":"837d0446e382f7a49dd628293066bf67","cid":"0-3","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/b5f16b8d-db49-479c-893b-ec3305f80c97/clear","body":{},"sessionId":"837d0446e382f7a49dd628293066bf67","cid":"0-3","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/b5f16b8d-db49-479c-893b-ec3305f80c97/clear","body":{},"result":{"value":null},"sessionId":"837d0446e382f7a49dd628293066bf67","cid":"0-3","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/b5f16b8d-db49-479c-893b-ec3305f80c97/value","body":{"text":"tomsmith"},"sessionId":"837d0446e382f7a49dd628293066bf67","cid":"0-3","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/b5f16b8d-db49-479c-893b-ec3305f80c97/value","body":{"text":"tomsmith"},"result":{"value":null},"sessionId":"837d0446e382f7a49dd628293066bf67","cid":"0-3","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#password"},"sessionId":"837d0446e382f7a49dd628293066bf67","cid":"0-3","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#password"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"8777c5bc-e8d9-4d1c-8fe1-ae4471a9a431"}},"sessionId":"837d0446e382f7a49dd628293066bf67","cid":"0-3","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/8777c5bc-e8d9-4d1c-8fe1-ae4471a9a431/clear","body":{},"sessionId":"837d0446e382f7a49dd628293066bf67","cid":"0-3","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/8777c5bc-e8d9-4d1c-8fe1-ae4471a9a431/clear","body":{},"result":{"value":null},"sessionId":"837d0446e382f7a49dd628293066bf67","cid":"0-3","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/8777c5bc-e8d9-4d1c-8fe1-ae4471a9a431/value","body":{"text":"SuperSecretPassword!"},"sessionId":"837d0446e382f7a49dd628293066bf67","cid":"0-3","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/8777c5bc-e8d9-4d1c-8fe1-ae4471a9a431/value","body":{"text":"SuperSecretPassword!"},"result":{"value":null},"sessionId":"837d0446e382f7a49dd628293066bf67","cid":"0-3","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"button[type=\"submit\"]"},"sessionId":"837d0446e382f7a49dd628293066bf67","cid":"0-3","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"button[type=\"submit\"]"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"a3b06394-9f0e-4ad1-acc1-74620e1ea85f"}},"sessionId":"837d0446e382f7a49dd628293066bf67","cid":"0-3","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"a3b06394-9f0e-4ad1-acc1-74620e1ea85f","ELEMENT":"a3b06394-9f0e-4ad1-acc1-74620e1ea85f"}]},"sessionId":"837d0446e382f7a49dd628293066bf67","cid":"0-3","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"a3b06394-9f0e-4ad1-acc1-74620e1ea85f","ELEMENT":"a3b06394-9f0e-4ad1-acc1-74620e1ea85f"}]},"result":{"value":true},"sessionId":"837d0446e382f7a49dd628293066bf67","cid":"0-3","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"button[type=\"submit\"]"},"sessionId":"837d0446e382f7a49dd628293066bf67","cid":"0-3","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"button[type=\"submit\"]"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"a3b06394-9f0e-4ad1-acc1-74620e1ea85f"}},"sessionId":"837d0446e382f7a49dd628293066bf67","cid":"0-3","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/a3b06394-9f0e-4ad1-acc1-74620e1ea85f/click","body":{},"sessionId":"837d0446e382f7a49dd628293066bf67","cid":"0-3","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/a3b06394-9f0e-4ad1-acc1-74620e1ea85f/click","body":{},"result":{"value":null},"sessionId":"837d0446e382f7a49dd628293066bf67","cid":"0-3","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#flash"},"sessionId":"837d0446e382f7a49dd628293066bf67","cid":"0-3","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#flash"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"9c60b11d-40c7-4dbf-acc7-e6a01b1ec291"}},"sessionId":"837d0446e382f7a49dd628293066bf67","cid":"0-3","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":"#flash"},"sessionId":"837d0446e382f7a49dd628293066bf67","cid":"0-3","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":"#flash"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"9c60b11d-40c7-4dbf-acc7-e6a01b1ec291"}]},"sessionId":"837d0446e382f7a49dd628293066bf67","cid":"0-3","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#flash"},"sessionId":"837d0446e382f7a49dd628293066bf67","cid":"0-3","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#flash"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"9c60b11d-40c7-4dbf-acc7-e6a01b1ec291"}},"sessionId":"837d0446e382f7a49dd628293066bf67","cid":"0-3","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/9c60b11d-40c7-4dbf-acc7-e6a01b1ec291/text","body":{},"sessionId":"837d0446e382f7a49dd628293066bf67","cid":"0-3","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/9c60b11d-40c7-4dbf-acc7-e6a01b1ec291/text","body":{},"result":{"value":"You logged into a secure area!\n×"},"sessionId":"837d0446e382f7a49dd628293066bf67","cid":"0-3","type":"result"}],"retries":0,"parent":"LoginPage","state":"passed","events":[],"errorIndex":0,"end":"2021-09-07T11:23:30.376Z"},{"type":"test","start":"2021-09-07T11:23:30.377Z","_duration":1242,"uid":"test-00-1","cid":"0-3","title":"should allow user logout","fullTitle":"LoginPage.should allow user logout","output":[{"method":"POST","endpoint":"/session/:sessionId/url","body":{"url":"https://the-internet.herokuapp.com/login"},"sessionId":"837d0446e382f7a49dd628293066bf67","cid":"0-3","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/url","body":{"url":"https://the-internet.herokuapp.com/login"},"result":{"value":null},"sessionId":"837d0446e382f7a49dd628293066bf67","cid":"0-3","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#username"},"sessionId":"837d0446e382f7a49dd628293066bf67","cid":"0-3","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#username"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"4b0e1fb9-b343-406c-82a7-4c4121553856"}},"sessionId":"837d0446e382f7a49dd628293066bf67","cid":"0-3","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"4b0e1fb9-b343-406c-82a7-4c4121553856","ELEMENT":"4b0e1fb9-b343-406c-82a7-4c4121553856"}]},"sessionId":"837d0446e382f7a49dd628293066bf67","cid":"0-3","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"4b0e1fb9-b343-406c-82a7-4c4121553856","ELEMENT":"4b0e1fb9-b343-406c-82a7-4c4121553856"}]},"result":{"value":true},"sessionId":"837d0446e382f7a49dd628293066bf67","cid":"0-3","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#username"},"sessionId":"837d0446e382f7a49dd628293066bf67","cid":"0-3","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#username"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"4b0e1fb9-b343-406c-82a7-4c4121553856"}},"sessionId":"837d0446e382f7a49dd628293066bf67","cid":"0-3","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/4b0e1fb9-b343-406c-82a7-4c4121553856/clear","body":{},"sessionId":"837d0446e382f7a49dd628293066bf67","cid":"0-3","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/4b0e1fb9-b343-406c-82a7-4c4121553856/clear","body":{},"result":{"value":null},"sessionId":"837d0446e382f7a49dd628293066bf67","cid":"0-3","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/4b0e1fb9-b343-406c-82a7-4c4121553856/value","body":{"text":"tomsmith"},"sessionId":"837d0446e382f7a49dd628293066bf67","cid":"0-3","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/4b0e1fb9-b343-406c-82a7-4c4121553856/value","body":{"text":"tomsmith"},"result":{"value":null},"sessionId":"837d0446e382f7a49dd628293066bf67","cid":"0-3","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#password"},"sessionId":"837d0446e382f7a49dd628293066bf67","cid":"0-3","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#password"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"0e431047-455e-499e-844f-553ccc4e56c2"}},"sessionId":"837d0446e382f7a49dd628293066bf67","cid":"0-3","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/0e431047-455e-499e-844f-553ccc4e56c2/clear","body":{},"sessionId":"837d0446e382f7a49dd628293066bf67","cid":"0-3","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/0e431047-455e-499e-844f-553ccc4e56c2/clear","body":{},"result":{"value":null},"sessionId":"837d0446e382f7a49dd628293066bf67","cid":"0-3","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/0e431047-455e-499e-844f-553ccc4e56c2/value","body":{"text":"SuperSecretPassword!"},"sessionId":"837d0446e382f7a49dd628293066bf67","cid":"0-3","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/0e431047-455e-499e-844f-553ccc4e56c2/value","body":{"text":"SuperSecretPassword!"},"result":{"value":null},"sessionId":"837d0446e382f7a49dd628293066bf67","cid":"0-3","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"button[type=\"submit\"]"},"sessionId":"837d0446e382f7a49dd628293066bf67","cid":"0-3","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"button[type=\"submit\"]"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"55ffc942-7b02-4dad-93ea-7d1bc8310dff"}},"sessionId":"837d0446e382f7a49dd628293066bf67","cid":"0-3","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"55ffc942-7b02-4dad-93ea-7d1bc8310dff","ELEMENT":"55ffc942-7b02-4dad-93ea-7d1bc8310dff"}]},"sessionId":"837d0446e382f7a49dd628293066bf67","cid":"0-3","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"55ffc942-7b02-4dad-93ea-7d1bc8310dff","ELEMENT":"55ffc942-7b02-4dad-93ea-7d1bc8310dff"}]},"result":{"value":true},"sessionId":"837d0446e382f7a49dd628293066bf67","cid":"0-3","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"button[type=\"submit\"]"},"sessionId":"837d0446e382f7a49dd628293066bf67","cid":"0-3","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"button[type=\"submit\"]"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"55ffc942-7b02-4dad-93ea-7d1bc8310dff"}},"sessionId":"837d0446e382f7a49dd628293066bf67","cid":"0-3","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/55ffc942-7b02-4dad-93ea-7d1bc8310dff/click","body":{},"sessionId":"837d0446e382f7a49dd628293066bf67","cid":"0-3","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/55ffc942-7b02-4dad-93ea-7d1bc8310dff/click","body":{},"result":{"value":null},"sessionId":"837d0446e382f7a49dd628293066bf67","cid":"0-3","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#flash"},"sessionId":"837d0446e382f7a49dd628293066bf67","cid":"0-3","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#flash"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"7b8659d7-2dc2-42bd-b77b-2e1f97bcd38c"}},"sessionId":"837d0446e382f7a49dd628293066bf67","cid":"0-3","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":"#flash"},"sessionId":"837d0446e382f7a49dd628293066bf67","cid":"0-3","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":"#flash"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"7b8659d7-2dc2-42bd-b77b-2e1f97bcd38c"}]},"sessionId":"837d0446e382f7a49dd628293066bf67","cid":"0-3","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#flash"},"sessionId":"837d0446e382f7a49dd628293066bf67","cid":"0-3","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#flash"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"7b8659d7-2dc2-42bd-b77b-2e1f97bcd38c"}},"sessionId":"837d0446e382f7a49dd628293066bf67","cid":"0-3","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/7b8659d7-2dc2-42bd-b77b-2e1f97bcd38c/text","body":{},"sessionId":"837d0446e382f7a49dd628293066bf67","cid":"0-3","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/7b8659d7-2dc2-42bd-b77b-2e1f97bcd38c/text","body":{},"result":{"value":"You logged into a secure area!\n×"},"sessionId":"837d0446e382f7a49dd628293066bf67","cid":"0-3","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//a[@href=\"/logout\"]"},"sessionId":"837d0446e382f7a49dd628293066bf67","cid":"0-3","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//a[@href=\"/logout\"]"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"8e887821-e64d-4da6-a873-c20a9bf12b84"}},"sessionId":"837d0446e382f7a49dd628293066bf67","cid":"0-3","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"8e887821-e64d-4da6-a873-c20a9bf12b84","ELEMENT":"8e887821-e64d-4da6-a873-c20a9bf12b84"}]},"sessionId":"837d0446e382f7a49dd628293066bf67","cid":"0-3","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"8e887821-e64d-4da6-a873-c20a9bf12b84","ELEMENT":"8e887821-e64d-4da6-a873-c20a9bf12b84"}]},"result":{"value":true},"sessionId":"837d0446e382f7a49dd628293066bf67","cid":"0-3","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//a[@href=\"/logout\"]"},"sessionId":"837d0446e382f7a49dd628293066bf67","cid":"0-3","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//a[@href=\"/logout\"]"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"8e887821-e64d-4da6-a873-c20a9bf12b84"}},"sessionId":"837d0446e382f7a49dd628293066bf67","cid":"0-3","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/8e887821-e64d-4da6-a873-c20a9bf12b84/click","body":{},"sessionId":"837d0446e382f7a49dd628293066bf67","cid":"0-3","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/8e887821-e64d-4da6-a873-c20a9bf12b84/click","body":{},"result":{"value":null},"sessionId":"837d0446e382f7a49dd628293066bf67","cid":"0-3","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#flash"},"sessionId":"837d0446e382f7a49dd628293066bf67","cid":"0-3","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#flash"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"ed05fbbc-b173-4ed6-bce4-57cb7a943037"}},"sessionId":"837d0446e382f7a49dd628293066bf67","cid":"0-3","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":"#flash"},"sessionId":"837d0446e382f7a49dd628293066bf67","cid":"0-3","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":"#flash"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"ed05fbbc-b173-4ed6-bce4-57cb7a943037"}]},"sessionId":"837d0446e382f7a49dd628293066bf67","cid":"0-3","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#flash"},"sessionId":"837d0446e382f7a49dd628293066bf67","cid":"0-3","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#flash"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"ed05fbbc-b173-4ed6-bce4-57cb7a943037"}},"sessionId":"837d0446e382f7a49dd628293066bf67","cid":"0-3","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/ed05fbbc-b173-4ed6-bce4-57cb7a943037/text","body":{},"sessionId":"837d0446e382f7a49dd628293066bf67","cid":"0-3","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/ed05fbbc-b173-4ed6-bce4-57cb7a943037/text","body":{},"result":{"value":"You logged out of the secure area!\n×"},"sessionId":"837d0446e382f7a49dd628293066bf67","cid":"0-3","type":"result"}],"retries":0,"parent":"LoginPage","state":"passed","events":[],"errorIndex":0,"end":"2021-09-07T11:23:31.619Z"}],"uid":"suite-0-0","cid":"0-3","file":"/Users/amiryamin/Desktop/projects/Mocha-WebdriverIO-Project/test/specs/test-login.js","title":"LoginPage","fullTitle":"LoginPage","parent":"","end":"2021-09-07T11:23:31.632Z"},{"type":"suite:start","start":"2021-09-07T11:23:31.633Z","_duration":399,"tests":[{"type":"test","start":"2021-09-07T11:23:31.633Z","_duration":397,"uid":"test-01-0","cid":"0-3","title":"should not allow guests to reach secure page","fullTitle":"SecurePage.should not allow guests to reach secure page","output":[],"retries":0,"parent":"SecurePage","state":"passed","events":[],"errorIndex":0,"end":"2021-09-07T11:23:32.030Z"}],"hooks":[],"suites":[],"hooksAndTests":[{"type":"test","start":"2021-09-07T11:23:31.633Z","_duration":397,"uid":"test-01-0","cid":"0-3","title":"should not allow guests to reach secure page","fullTitle":"SecurePage.should not allow guests to reach secure page","output":[{"method":"POST","endpoint":"/session/:sessionId/url","body":{"url":"https://the-internet.herokuapp.com/secure"},"sessionId":"837d0446e382f7a49dd628293066bf67","cid":"0-3","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/url","body":{"url":"https://the-internet.herokuapp.com/secure"},"result":{"value":null},"sessionId":"837d0446e382f7a49dd628293066bf67","cid":"0-3","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"sessionId":"837d0446e382f7a49dd628293066bf67","cid":"0-3","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"result":{"value":"https://the-internet.herokuapp.com/login"},"sessionId":"837d0446e382f7a49dd628293066bf67","cid":"0-3","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#flash"},"sessionId":"837d0446e382f7a49dd628293066bf67","cid":"0-3","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#flash"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"413c6a70-8e98-4de2-ad56-696416867182"}},"sessionId":"837d0446e382f7a49dd628293066bf67","cid":"0-3","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":"#flash"},"sessionId":"837d0446e382f7a49dd628293066bf67","cid":"0-3","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":"#flash"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"413c6a70-8e98-4de2-ad56-696416867182"}]},"sessionId":"837d0446e382f7a49dd628293066bf67","cid":"0-3","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#flash"},"sessionId":"837d0446e382f7a49dd628293066bf67","cid":"0-3","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#flash"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"413c6a70-8e98-4de2-ad56-696416867182"}},"sessionId":"837d0446e382f7a49dd628293066bf67","cid":"0-3","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/413c6a70-8e98-4de2-ad56-696416867182/text","body":{},"sessionId":"837d0446e382f7a49dd628293066bf67","cid":"0-3","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/413c6a70-8e98-4de2-ad56-696416867182/text","body":{},"result":{"value":"You must login to view the secure area!\n×"},"sessionId":"837d0446e382f7a49dd628293066bf67","cid":"0-3","type":"result"},{"method":"DELETE","endpoint":"/session/:sessionId","body":{},"sessionId":"837d0446e382f7a49dd628293066bf67","cid":"0-3","type":"command"},{"method":"DELETE","endpoint":"/session/:sessionId","body":{},"result":{"value":null},"sessionId":"837d0446e382f7a49dd628293066bf67","cid":"0-3","type":"result"}],"retries":0,"parent":"SecurePage","state":"passed","events":[],"errorIndex":0,"end":"2021-09-07T11:23:32.030Z"}],"uid":"suite-0-1","cid":"0-3","file":"/Users/amiryamin/Desktop/projects/Mocha-WebdriverIO-Project/test/specs/test-login.js","title":"SecurePage","fullTitle":"SecurePage","parent":"","end":"2021-09-07T11:23:32.032Z"}],"reportFile":"/Users/amiryamin/Desktop/projects/Mocha-WebdriverIO-Project/reports/html-reports/master-report.html"}