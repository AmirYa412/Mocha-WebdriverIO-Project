{"info":{"type":"runner","start":"2021-09-07T15:07:38.368Z","_duration":2791,"cid":"0-0","capabilities":{"acceptInsecureCerts":true,"browserName":"chrome","browserVersion":"93.0.4577.63","chrome":{"chromedriverVersion":"92.0.4515.107 (87a818b10553a07434ea9e2b6dccf3cbe7895134-refs/branch-heads/4515@{#1634})","userDataDir":"/var/folders/mz/jf8rc3lj3t5c5r9lk5z1rrzw0000gp/T/.com.google.Chrome.5Dru2h"},"goog:chromeOptions":{"debuggerAddress":"localhost:60257"},"networkConnectionEnabled":false,"pageLoadStrategy":"normal","platformName":"mac os x","proxy":{},"setWindowRect":true,"strictFileInteractability":false,"timeouts":{"implicit":0,"pageLoad":300000,"script":30000},"unhandledPromptBehavior":"dismiss and notify","webauthn:extension:credBlob":true,"webauthn:extension:largeBlob":true,"webauthn:virtualAuthenticators":true,"sessionId":"7c2d0ad12a5a1d6930a0cb8d5c3b93b9"},"sanitizedCapabilities":"chrome.93_0_4577_63.macosx","config":{"protocol":"http","hostname":"localhost","port":9515,"path":"/","capabilities":{"browserName":"chrome","acceptInsecureCerts":true},"logLevel":"silent","connectionRetryTimeout":120000,"connectionRetryCount":3,"logLevels":{},"strictSSL":true,"requestedCapabilities":{"browserName":"chrome","acceptInsecureCerts":true},"specs":["./test/specs/**/*.js"],"exclude":[],"suites":{"login":["./test/specs/test-login.js"],"alerts":["./test/specs/test-js-alert.js"],"elements":["./test/specs/test-add-elements.js"],"hovers":["./test/specs/test-hovers.js"]},"baseUrl":"https://the-internet.herokuapp.com","bail":0,"waitforInterval":500,"waitforTimeout":10000,"framework":"mocha","reporters":["spec",["allure",{"outputDir":"reports/allure/allure-results"}],["html-nice",{"outputDir":"reports/html-reports/","filename":"report.html","reportTitle":"Test Report Title","showInBrowser":true,"collapseTests":false,"useOnAfterCommandForScreenshot":false}]],"services":["chromedriver"],"execArgv":[],"maxInstances":5,"maxInstancesPerCapability":100,"filesToWatch":[],"onPrepare":[null],"onWorkerStart":[],"before":[],"beforeSession":[],"beforeSuite":[],"beforeHook":[],"beforeTest":[],"beforeCommand":[],"afterCommand":[],"afterTest":[],"afterHook":[],"afterSuite":[],"afterSession":[],"after":[],"onComplete":[null],"onReload":[],"automationProtocol":"webdriver"},"specs":["/Users/amiryamin/Desktop/projects/Mocha-WebdriverIO-Project/test/specs/test-add-elements.js"],"sessionId":"7c2d0ad12a5a1d6930a0cb8d5c3b93b9","isMultiremote":false,"instanceOptions":{"7c2d0ad12a5a1d6930a0cb8d5c3b93b9":{"protocol":"http","hostname":"localhost","port":9515,"path":"/","capabilities":{"browserName":"chrome","acceptInsecureCerts":true},"logLevel":"silent","connectionRetryTimeout":120000,"connectionRetryCount":3,"logLevels":{},"strictSSL":true,"requestedCapabilities":{"browserName":"chrome","acceptInsecureCerts":true},"specs":["./test/specs/**/*.js"],"exclude":[],"suites":{"login":["./test/specs/test-login.js"],"alerts":["./test/specs/test-js-alert.js"],"elements":["./test/specs/test-add-elements.js"],"hovers":["./test/specs/test-hovers.js"]},"baseUrl":"https://the-internet.herokuapp.com","bail":0,"waitforInterval":500,"waitforTimeout":10000,"framework":"mocha","reporters":["spec",["allure",{"outputDir":"reports/allure/allure-results"}],["html-nice",{"outputDir":"reports/html-reports/","filename":"report.html","reportTitle":"Test Report Title","showInBrowser":true,"collapseTests":false,"useOnAfterCommandForScreenshot":false}]],"services":["chromedriver"],"execArgv":[],"maxInstances":5,"maxInstancesPerCapability":100,"filesToWatch":[],"onPrepare":[null],"onWorkerStart":[],"before":[],"beforeSession":[],"beforeSuite":[],"beforeHook":[],"beforeTest":[],"beforeCommand":[],"afterCommand":[],"afterTest":[],"afterHook":[],"afterSuite":[],"afterSession":[],"after":[],"onComplete":[null],"onReload":[],"automationProtocol":"webdriver"}},"retry":0,"failures":0,"retries":0,"end":"2021-09-07T15:07:41.159Z"},"metrics":{"passed":11,"skipped":0,"failed":0,"duration":20042,"start":"2021-09-07T15:07:38.376Z","end":"2021-09-07T15:07:58.418Z"},"title":"Master Report","suites":[{"type":"suite:start","start":"2021-09-07T15:07:38.376Z","_duration":2728,"tests":[{"type":"test","start":"2021-09-07T15:07:38.378Z","_duration":2178,"uid":"test-00-0","cid":"0-0","title":"should create a single element","fullTitle":"AddElementsPage.should create a single element","output":[],"retries":0,"parent":"AddElementsPage","state":"passed","events":[],"errorIndex":0,"end":"2021-09-07T15:07:40.556Z"},{"type":"test","start":"2021-09-07T15:07:40.557Z","_duration":264,"uid":"test-00-1","cid":"0-0","title":"should create 2 elements","fullTitle":"AddElementsPage.should create 2 elements","output":[],"retries":0,"parent":"AddElementsPage","state":"passed","events":[],"errorIndex":0,"end":"2021-09-07T15:07:40.821Z"},{"type":"test","start":"2021-09-07T15:07:40.821Z","_duration":275,"uid":"test-00-2","cid":"0-0","title":"should delete single element","fullTitle":"AddElementsPage.should delete single element","output":[],"retries":0,"parent":"AddElementsPage","state":"passed","events":[],"errorIndex":0,"end":"2021-09-07T15:07:41.096Z"}],"hooks":[],"suites":[],"hooksAndTests":[{"type":"test","start":"2021-09-07T15:07:38.378Z","_duration":2178,"uid":"test-00-0","cid":"0-0","title":"should create a single element","fullTitle":"AddElementsPage.should create a single element","output":[{"method":"POST","endpoint":"/session/:sessionId/url","body":{"url":"https://the-internet.herokuapp.com/add_remove_elements/"},"sessionId":"7c2d0ad12a5a1d6930a0cb8d5c3b93b9","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/url","body":{"url":"https://the-internet.herokuapp.com/add_remove_elements/"},"result":{"value":null},"sessionId":"7c2d0ad12a5a1d6930a0cb8d5c3b93b9","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//button[@onclick=\"addElement()\"]"},"sessionId":"7c2d0ad12a5a1d6930a0cb8d5c3b93b9","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//button[@onclick=\"addElement()\"]"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"da605bec-952f-4a94-8e52-35ef1a2653e0"}},"sessionId":"7c2d0ad12a5a1d6930a0cb8d5c3b93b9","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/da605bec-952f-4a94-8e52-35ef1a2653e0/click","body":{},"sessionId":"7c2d0ad12a5a1d6930a0cb8d5c3b93b9","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/da605bec-952f-4a94-8e52-35ef1a2653e0/click","body":{},"result":{"value":null},"sessionId":"7c2d0ad12a5a1d6930a0cb8d5c3b93b9","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"xpath","value":"//div[@id=\"elements\"]//button"},"sessionId":"7c2d0ad12a5a1d6930a0cb8d5c3b93b9","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"xpath","value":"//div[@id=\"elements\"]//button"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"90fee9f0-1958-468d-9eed-ae787d863db5"}]},"sessionId":"7c2d0ad12a5a1d6930a0cb8d5c3b93b9","cid":"0-0","type":"result"}],"retries":0,"parent":"AddElementsPage","state":"passed","events":[],"errorIndex":0,"end":"2021-09-07T15:07:40.556Z"},{"type":"test","start":"2021-09-07T15:07:40.557Z","_duration":264,"uid":"test-00-1","cid":"0-0","title":"should create 2 elements","fullTitle":"AddElementsPage.should create 2 elements","output":[{"method":"POST","endpoint":"/session/:sessionId/url","body":{"url":"https://the-internet.herokuapp.com/add_remove_elements/"},"sessionId":"7c2d0ad12a5a1d6930a0cb8d5c3b93b9","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/url","body":{"url":"https://the-internet.herokuapp.com/add_remove_elements/"},"result":{"value":null},"sessionId":"7c2d0ad12a5a1d6930a0cb8d5c3b93b9","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//button[@onclick=\"addElement()\"]"},"sessionId":"7c2d0ad12a5a1d6930a0cb8d5c3b93b9","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//button[@onclick=\"addElement()\"]"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"ca4690d1-4c8e-419f-b1f6-18bd4dd95034"}},"sessionId":"7c2d0ad12a5a1d6930a0cb8d5c3b93b9","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/ca4690d1-4c8e-419f-b1f6-18bd4dd95034/click","body":{},"sessionId":"7c2d0ad12a5a1d6930a0cb8d5c3b93b9","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/ca4690d1-4c8e-419f-b1f6-18bd4dd95034/click","body":{},"result":{"value":null},"sessionId":"7c2d0ad12a5a1d6930a0cb8d5c3b93b9","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//button[@onclick=\"addElement()\"]"},"sessionId":"7c2d0ad12a5a1d6930a0cb8d5c3b93b9","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//button[@onclick=\"addElement()\"]"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"ca4690d1-4c8e-419f-b1f6-18bd4dd95034"}},"sessionId":"7c2d0ad12a5a1d6930a0cb8d5c3b93b9","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/ca4690d1-4c8e-419f-b1f6-18bd4dd95034/click","body":{},"sessionId":"7c2d0ad12a5a1d6930a0cb8d5c3b93b9","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/ca4690d1-4c8e-419f-b1f6-18bd4dd95034/click","body":{},"result":{"value":null},"sessionId":"7c2d0ad12a5a1d6930a0cb8d5c3b93b9","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"xpath","value":"//div[@id=\"elements\"]//button"},"sessionId":"7c2d0ad12a5a1d6930a0cb8d5c3b93b9","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"xpath","value":"//div[@id=\"elements\"]//button"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"d50f7088-bf87-4ce5-a424-f285d0e180fe"},{"element-6066-11e4-a52e-4f735466cecf":"69537603-2f2a-4cef-a303-208ccffeaad6"}]},"sessionId":"7c2d0ad12a5a1d6930a0cb8d5c3b93b9","cid":"0-0","type":"result"}],"retries":0,"parent":"AddElementsPage","state":"passed","events":[],"errorIndex":0,"end":"2021-09-07T15:07:40.821Z"},{"type":"test","start":"2021-09-07T15:07:40.821Z","_duration":275,"uid":"test-00-2","cid":"0-0","title":"should delete single element","fullTitle":"AddElementsPage.should delete single element","output":[{"method":"POST","endpoint":"/session/:sessionId/url","body":{"url":"https://the-internet.herokuapp.com/add_remove_elements/"},"sessionId":"7c2d0ad12a5a1d6930a0cb8d5c3b93b9","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/url","body":{"url":"https://the-internet.herokuapp.com/add_remove_elements/"},"result":{"value":null},"sessionId":"7c2d0ad12a5a1d6930a0cb8d5c3b93b9","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//button[@onclick=\"addElement()\"]"},"sessionId":"7c2d0ad12a5a1d6930a0cb8d5c3b93b9","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//button[@onclick=\"addElement()\"]"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"481cad05-f901-417b-a1d5-871e17fd560e"}},"sessionId":"7c2d0ad12a5a1d6930a0cb8d5c3b93b9","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/481cad05-f901-417b-a1d5-871e17fd560e/click","body":{},"sessionId":"7c2d0ad12a5a1d6930a0cb8d5c3b93b9","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/481cad05-f901-417b-a1d5-871e17fd560e/click","body":{},"result":{"value":null},"sessionId":"7c2d0ad12a5a1d6930a0cb8d5c3b93b9","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"xpath","value":"//div[@id=\"elements\"]//button"},"sessionId":"7c2d0ad12a5a1d6930a0cb8d5c3b93b9","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"xpath","value":"//div[@id=\"elements\"]//button"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"88e13d38-ea37-43f7-b97e-240c18231c8b"}]},"sessionId":"7c2d0ad12a5a1d6930a0cb8d5c3b93b9","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"xpath","value":"//div[@id=\"elements\"]//button"},"sessionId":"7c2d0ad12a5a1d6930a0cb8d5c3b93b9","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"xpath","value":"//div[@id=\"elements\"]//button"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"88e13d38-ea37-43f7-b97e-240c18231c8b"}]},"sessionId":"7c2d0ad12a5a1d6930a0cb8d5c3b93b9","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/88e13d38-ea37-43f7-b97e-240c18231c8b/click","body":{},"sessionId":"7c2d0ad12a5a1d6930a0cb8d5c3b93b9","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/88e13d38-ea37-43f7-b97e-240c18231c8b/click","body":{},"result":{"value":null},"sessionId":"7c2d0ad12a5a1d6930a0cb8d5c3b93b9","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"xpath","value":"//div[@id=\"elements\"]//button"},"sessionId":"7c2d0ad12a5a1d6930a0cb8d5c3b93b9","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"xpath","value":"//div[@id=\"elements\"]//button"},"result":{"value":[]},"sessionId":"7c2d0ad12a5a1d6930a0cb8d5c3b93b9","cid":"0-0","type":"result"},{"method":"DELETE","endpoint":"/session/:sessionId","body":{},"sessionId":"7c2d0ad12a5a1d6930a0cb8d5c3b93b9","cid":"0-0","type":"command"},{"method":"DELETE","endpoint":"/session/:sessionId","body":{},"result":{"value":null},"sessionId":"7c2d0ad12a5a1d6930a0cb8d5c3b93b9","cid":"0-0","type":"result"}],"retries":0,"parent":"AddElementsPage","state":"passed","events":[],"errorIndex":0,"end":"2021-09-07T15:07:41.096Z"}],"uid":"suite-0-0","cid":"0-0","file":"/Users/amiryamin/Desktop/projects/Mocha-WebdriverIO-Project/test/specs/test-add-elements.js","title":"AddElementsPage","fullTitle":"AddElementsPage","parent":"","end":"2021-09-07T15:07:41.104Z"},{"type":"suite:start","start":"2021-09-07T15:07:43.373Z","_duration":2792,"tests":[{"type":"test","start":"2021-09-07T15:07:43.373Z","_duration":2223,"uid":"test-00-0","cid":"0-1","title":"should show expected figure info on hover","fullTitle":"HoversPage.should show expected figure info on hover","output":[],"retries":0,"parent":"HoversPage","state":"passed","events":[],"errorIndex":0,"end":"2021-09-07T15:07:45.596Z"},{"type":"test","start":"2021-09-07T15:07:45.597Z","_duration":556,"uid":"test-00-1","cid":"0-1","title":"should navigate to expected profile","fullTitle":"HoversPage.should navigate to expected profile","output":[],"retries":0,"parent":"HoversPage","state":"passed","events":[],"errorIndex":0,"end":"2021-09-07T15:07:46.153Z"}],"hooks":[],"suites":[],"hooksAndTests":[{"type":"test","start":"2021-09-07T15:07:43.373Z","_duration":2223,"uid":"test-00-0","cid":"0-1","title":"should show expected figure info on hover","fullTitle":"HoversPage.should show expected figure info on hover","output":[{"method":"POST","endpoint":"/session/:sessionId/url","body":{"url":"https://the-internet.herokuapp.com/hovers"},"sessionId":"fee44cd7d3e503a6597e17c2e7ca00f0","cid":"0-1","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/url","body":{"url":"https://the-internet.herokuapp.com/hovers"},"result":{"value":null},"sessionId":"fee44cd7d3e503a6597e17c2e7ca00f0","cid":"0-1","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"xpath","value":"//div[@class=\"figure\"]/img"},"sessionId":"fee44cd7d3e503a6597e17c2e7ca00f0","cid":"0-1","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"xpath","value":"//div[@class=\"figure\"]/img"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"08ed9f95-e3e5-4c2b-b73d-87651fa9cb64"},{"element-6066-11e4-a52e-4f735466cecf":"7bb01b19-ecb7-47c0-b6de-15d41f904d62"},{"element-6066-11e4-a52e-4f735466cecf":"3129533f-275c-4e26-a385-bca6084ed2e3"}]},"sessionId":"fee44cd7d3e503a6597e17c2e7ca00f0","cid":"0-1","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"08ed9f95-e3e5-4c2b-b73d-87651fa9cb64","ELEMENT":"08ed9f95-e3e5-4c2b-b73d-87651fa9cb64"}]},"sessionId":"fee44cd7d3e503a6597e17c2e7ca00f0","cid":"0-1","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"08ed9f95-e3e5-4c2b-b73d-87651fa9cb64","ELEMENT":"08ed9f95-e3e5-4c2b-b73d-87651fa9cb64"}]},"result":{"value":true},"sessionId":"fee44cd7d3e503a6597e17c2e7ca00f0","cid":"0-1","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"xpath","value":"//div[@class=\"figure\"]/img"},"sessionId":"fee44cd7d3e503a6597e17c2e7ca00f0","cid":"0-1","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"xpath","value":"//div[@class=\"figure\"]/img"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"08ed9f95-e3e5-4c2b-b73d-87651fa9cb64"},{"element-6066-11e4-a52e-4f735466cecf":"7bb01b19-ecb7-47c0-b6de-15d41f904d62"},{"element-6066-11e4-a52e-4f735466cecf":"3129533f-275c-4e26-a385-bca6084ed2e3"}]},"sessionId":"fee44cd7d3e503a6597e17c2e7ca00f0","cid":"0-1","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/08ed9f95-e3e5-4c2b-b73d-87651fa9cb64/rect","body":{},"sessionId":"fee44cd7d3e503a6597e17c2e7ca00f0","cid":"0-1","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/08ed9f95-e3e5-4c2b-b73d-87651fa9cb64/rect","body":{},"result":{"value":{"height":160,"width":160,"x":115,"y":132.890625}},"sessionId":"fee44cd7d3e503a6597e17c2e7ca00f0","cid":"0-1","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function () {\n        return { scrollX: this.pageXOffset, scrollY: this.pageYOffset };\n    }).apply(null, arguments)","args":[]},"sessionId":"fee44cd7d3e503a6597e17c2e7ca00f0","cid":"0-1","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function () {\n        return { scrollX: this.pageXOffset, scrollY: this.pageYOffset };\n    }).apply(null, arguments)","args":[]},"result":{"value":{"scrollX":0,"scrollY":0}},"sessionId":"fee44cd7d3e503a6597e17c2e7ca00f0","cid":"0-1","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/actions","body":{"actions":[{"type":"pointer","id":"finger1","parameters":{"pointerType":"mouse"},"actions":[{"type":"pointerMove","duration":0,"x":195,"y":212}]}]},"sessionId":"fee44cd7d3e503a6597e17c2e7ca00f0","cid":"0-1","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/actions","body":{"actions":[{"type":"pointer","id":"finger1","parameters":{"pointerType":"mouse"},"actions":[{"type":"pointerMove","duration":0,"x":195,"y":212}]}]},"result":{"value":null},"sessionId":"fee44cd7d3e503a6597e17c2e7ca00f0","cid":"0-1","type":"result"},{"method":"DELETE","endpoint":"/session/:sessionId/actions","body":{},"sessionId":"fee44cd7d3e503a6597e17c2e7ca00f0","cid":"0-1","type":"command"},{"method":"DELETE","endpoint":"/session/:sessionId/actions","body":{},"result":{"value":null},"sessionId":"fee44cd7d3e503a6597e17c2e7ca00f0","cid":"0-1","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"xpath","value":"//div[@class=\"figcaption\"]/h5"},"sessionId":"fee44cd7d3e503a6597e17c2e7ca00f0","cid":"0-1","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"xpath","value":"//div[@class=\"figcaption\"]/h5"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"e245521c-0dde-4cdd-b664-623350f4732f"},{"element-6066-11e4-a52e-4f735466cecf":"4f5b124c-9569-466d-acca-eab62e081e97"},{"element-6066-11e4-a52e-4f735466cecf":"ee7119f2-9ec7-492b-937a-faf925083cc8"}]},"sessionId":"fee44cd7d3e503a6597e17c2e7ca00f0","cid":"0-1","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"e245521c-0dde-4cdd-b664-623350f4732f","ELEMENT":"e245521c-0dde-4cdd-b664-623350f4732f"}]},"sessionId":"fee44cd7d3e503a6597e17c2e7ca00f0","cid":"0-1","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"e245521c-0dde-4cdd-b664-623350f4732f","ELEMENT":"e245521c-0dde-4cdd-b664-623350f4732f"}]},"result":{"value":true},"sessionId":"fee44cd7d3e503a6597e17c2e7ca00f0","cid":"0-1","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"xpath","value":"//div[@class=\"figcaption\"]/h5"},"sessionId":"fee44cd7d3e503a6597e17c2e7ca00f0","cid":"0-1","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"xpath","value":"//div[@class=\"figcaption\"]/h5"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"e245521c-0dde-4cdd-b664-623350f4732f"},{"element-6066-11e4-a52e-4f735466cecf":"4f5b124c-9569-466d-acca-eab62e081e97"},{"element-6066-11e4-a52e-4f735466cecf":"ee7119f2-9ec7-492b-937a-faf925083cc8"}]},"sessionId":"fee44cd7d3e503a6597e17c2e7ca00f0","cid":"0-1","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/e245521c-0dde-4cdd-b664-623350f4732f/text","body":{},"sessionId":"fee44cd7d3e503a6597e17c2e7ca00f0","cid":"0-1","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/e245521c-0dde-4cdd-b664-623350f4732f/text","body":{},"result":{"value":"name: user1"},"sessionId":"fee44cd7d3e503a6597e17c2e7ca00f0","cid":"0-1","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"xpath","value":"//div[@class=\"figcaption\"]/a"},"sessionId":"fee44cd7d3e503a6597e17c2e7ca00f0","cid":"0-1","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"xpath","value":"//div[@class=\"figcaption\"]/a"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"aa44df9e-c962-4e37-8040-d8927a7e8940"},{"element-6066-11e4-a52e-4f735466cecf":"6e5e3602-314b-4078-a62b-d064e332e8f2"},{"element-6066-11e4-a52e-4f735466cecf":"6d0cb49b-860e-48bb-817c-bb61523cdcca"}]},"sessionId":"fee44cd7d3e503a6597e17c2e7ca00f0","cid":"0-1","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/aa44df9e-c962-4e37-8040-d8927a7e8940/attribute/href","body":{},"sessionId":"fee44cd7d3e503a6597e17c2e7ca00f0","cid":"0-1","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/aa44df9e-c962-4e37-8040-d8927a7e8940/attribute/href","body":{},"result":{"value":"/users/1"},"sessionId":"fee44cd7d3e503a6597e17c2e7ca00f0","cid":"0-1","type":"result"}],"retries":0,"parent":"HoversPage","state":"passed","events":[],"errorIndex":0,"end":"2021-09-07T15:07:45.596Z"},{"type":"test","start":"2021-09-07T15:07:45.597Z","_duration":556,"uid":"test-00-1","cid":"0-1","title":"should navigate to expected profile","fullTitle":"HoversPage.should navigate to expected profile","output":[{"method":"POST","endpoint":"/session/:sessionId/url","body":{"url":"https://the-internet.herokuapp.com/hovers"},"sessionId":"fee44cd7d3e503a6597e17c2e7ca00f0","cid":"0-1","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/url","body":{"url":"https://the-internet.herokuapp.com/hovers"},"result":{"value":null},"sessionId":"fee44cd7d3e503a6597e17c2e7ca00f0","cid":"0-1","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"xpath","value":"//div[@class=\"figure\"]/img"},"sessionId":"fee44cd7d3e503a6597e17c2e7ca00f0","cid":"0-1","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"xpath","value":"//div[@class=\"figure\"]/img"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"f30ad013-f7de-435c-80ab-bc9210b9b733"},{"element-6066-11e4-a52e-4f735466cecf":"2ea972bf-9b4a-4bb4-ae88-63ccebb3a91e"},{"element-6066-11e4-a52e-4f735466cecf":"70254381-495c-43de-9ab8-a4bbd6c91d52"}]},"sessionId":"fee44cd7d3e503a6597e17c2e7ca00f0","cid":"0-1","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"70254381-495c-43de-9ab8-a4bbd6c91d52","ELEMENT":"70254381-495c-43de-9ab8-a4bbd6c91d52"}]},"sessionId":"fee44cd7d3e503a6597e17c2e7ca00f0","cid":"0-1","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"70254381-495c-43de-9ab8-a4bbd6c91d52","ELEMENT":"70254381-495c-43de-9ab8-a4bbd6c91d52"}]},"result":{"value":true},"sessionId":"fee44cd7d3e503a6597e17c2e7ca00f0","cid":"0-1","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"xpath","value":"//div[@class=\"figure\"]/img"},"sessionId":"fee44cd7d3e503a6597e17c2e7ca00f0","cid":"0-1","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"xpath","value":"//div[@class=\"figure\"]/img"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"f30ad013-f7de-435c-80ab-bc9210b9b733"},{"element-6066-11e4-a52e-4f735466cecf":"2ea972bf-9b4a-4bb4-ae88-63ccebb3a91e"},{"element-6066-11e4-a52e-4f735466cecf":"70254381-495c-43de-9ab8-a4bbd6c91d52"}]},"sessionId":"fee44cd7d3e503a6597e17c2e7ca00f0","cid":"0-1","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/70254381-495c-43de-9ab8-a4bbd6c91d52/rect","body":{},"sessionId":"fee44cd7d3e503a6597e17c2e7ca00f0","cid":"0-1","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/70254381-495c-43de-9ab8-a4bbd6c91d52/rect","body":{},"result":{"value":{"height":160,"width":160,"x":475,"y":132.890625}},"sessionId":"fee44cd7d3e503a6597e17c2e7ca00f0","cid":"0-1","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function () {\n        return { scrollX: this.pageXOffset, scrollY: this.pageYOffset };\n    }).apply(null, arguments)","args":[]},"sessionId":"fee44cd7d3e503a6597e17c2e7ca00f0","cid":"0-1","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function () {\n        return { scrollX: this.pageXOffset, scrollY: this.pageYOffset };\n    }).apply(null, arguments)","args":[]},"result":{"value":{"scrollX":0,"scrollY":0}},"sessionId":"fee44cd7d3e503a6597e17c2e7ca00f0","cid":"0-1","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/actions","body":{"actions":[{"type":"pointer","id":"finger1","parameters":{"pointerType":"mouse"},"actions":[{"type":"pointerMove","duration":0,"x":555,"y":212}]}]},"sessionId":"fee44cd7d3e503a6597e17c2e7ca00f0","cid":"0-1","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/actions","body":{"actions":[{"type":"pointer","id":"finger1","parameters":{"pointerType":"mouse"},"actions":[{"type":"pointerMove","duration":0,"x":555,"y":212}]}]},"result":{"value":null},"sessionId":"fee44cd7d3e503a6597e17c2e7ca00f0","cid":"0-1","type":"result"},{"method":"DELETE","endpoint":"/session/:sessionId/actions","body":{},"sessionId":"fee44cd7d3e503a6597e17c2e7ca00f0","cid":"0-1","type":"command"},{"method":"DELETE","endpoint":"/session/:sessionId/actions","body":{},"result":{"value":null},"sessionId":"fee44cd7d3e503a6597e17c2e7ca00f0","cid":"0-1","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"xpath","value":"//div[@class=\"figcaption\"]/h5"},"sessionId":"fee44cd7d3e503a6597e17c2e7ca00f0","cid":"0-1","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"xpath","value":"//div[@class=\"figcaption\"]/h5"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"f59fe75c-2b6e-4b10-9162-c6b670364250"},{"element-6066-11e4-a52e-4f735466cecf":"f4e1ba62-3155-487b-af5e-bb61a40eeafb"},{"element-6066-11e4-a52e-4f735466cecf":"836fcab1-1017-497c-bdca-548e26129d5b"}]},"sessionId":"fee44cd7d3e503a6597e17c2e7ca00f0","cid":"0-1","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"836fcab1-1017-497c-bdca-548e26129d5b","ELEMENT":"836fcab1-1017-497c-bdca-548e26129d5b"}]},"sessionId":"fee44cd7d3e503a6597e17c2e7ca00f0","cid":"0-1","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"836fcab1-1017-497c-bdca-548e26129d5b","ELEMENT":"836fcab1-1017-497c-bdca-548e26129d5b"}]},"result":{"value":true},"sessionId":"fee44cd7d3e503a6597e17c2e7ca00f0","cid":"0-1","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"xpath","value":"//div[@class=\"figcaption\"]/h5"},"sessionId":"fee44cd7d3e503a6597e17c2e7ca00f0","cid":"0-1","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"xpath","value":"//div[@class=\"figcaption\"]/h5"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"f59fe75c-2b6e-4b10-9162-c6b670364250"},{"element-6066-11e4-a52e-4f735466cecf":"f4e1ba62-3155-487b-af5e-bb61a40eeafb"},{"element-6066-11e4-a52e-4f735466cecf":"836fcab1-1017-497c-bdca-548e26129d5b"}]},"sessionId":"fee44cd7d3e503a6597e17c2e7ca00f0","cid":"0-1","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/836fcab1-1017-497c-bdca-548e26129d5b/text","body":{},"sessionId":"fee44cd7d3e503a6597e17c2e7ca00f0","cid":"0-1","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/836fcab1-1017-497c-bdca-548e26129d5b/text","body":{},"result":{"value":"name: user3"},"sessionId":"fee44cd7d3e503a6597e17c2e7ca00f0","cid":"0-1","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"xpath","value":"//div[@class=\"figcaption\"]/a"},"sessionId":"fee44cd7d3e503a6597e17c2e7ca00f0","cid":"0-1","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"xpath","value":"//div[@class=\"figcaption\"]/a"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"4d6019e8-25e0-4643-8ac9-ccae7749c8df"},{"element-6066-11e4-a52e-4f735466cecf":"fe698440-6dd8-4f2d-8e0d-64dbe9cb0d11"},{"element-6066-11e4-a52e-4f735466cecf":"a55ee854-6bfe-4b39-8f56-3653f07ca290"}]},"sessionId":"fee44cd7d3e503a6597e17c2e7ca00f0","cid":"0-1","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/a55ee854-6bfe-4b39-8f56-3653f07ca290/attribute/href","body":{},"sessionId":"fee44cd7d3e503a6597e17c2e7ca00f0","cid":"0-1","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/a55ee854-6bfe-4b39-8f56-3653f07ca290/attribute/href","body":{},"result":{"value":"/users/3"},"sessionId":"fee44cd7d3e503a6597e17c2e7ca00f0","cid":"0-1","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"xpath","value":"//div[@class=\"figcaption\"]/a"},"sessionId":"fee44cd7d3e503a6597e17c2e7ca00f0","cid":"0-1","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"xpath","value":"//div[@class=\"figcaption\"]/a"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"4d6019e8-25e0-4643-8ac9-ccae7749c8df"},{"element-6066-11e4-a52e-4f735466cecf":"fe698440-6dd8-4f2d-8e0d-64dbe9cb0d11"},{"element-6066-11e4-a52e-4f735466cecf":"a55ee854-6bfe-4b39-8f56-3653f07ca290"}]},"sessionId":"fee44cd7d3e503a6597e17c2e7ca00f0","cid":"0-1","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/a55ee854-6bfe-4b39-8f56-3653f07ca290/click","body":{},"sessionId":"fee44cd7d3e503a6597e17c2e7ca00f0","cid":"0-1","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/a55ee854-6bfe-4b39-8f56-3653f07ca290/click","body":{},"result":{"value":null},"sessionId":"fee44cd7d3e503a6597e17c2e7ca00f0","cid":"0-1","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"sessionId":"fee44cd7d3e503a6597e17c2e7ca00f0","cid":"0-1","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"result":{"value":"https://the-internet.herokuapp.com/users/3"},"sessionId":"fee44cd7d3e503a6597e17c2e7ca00f0","cid":"0-1","type":"result"},{"method":"DELETE","endpoint":"/session/:sessionId","body":{},"sessionId":"fee44cd7d3e503a6597e17c2e7ca00f0","cid":"0-1","type":"command"},{"method":"DELETE","endpoint":"/session/:sessionId","body":{},"result":{"value":null},"sessionId":"fee44cd7d3e503a6597e17c2e7ca00f0","cid":"0-1","type":"result"}],"retries":0,"parent":"HoversPage","state":"passed","events":[],"errorIndex":0,"end":"2021-09-07T15:07:46.153Z"}],"uid":"suite-0-0","cid":"0-1","file":"/Users/amiryamin/Desktop/projects/Mocha-WebdriverIO-Project/test/specs/test-hovers.js","title":"HoversPage","fullTitle":"HoversPage","parent":"","end":"2021-09-07T15:07:46.165Z"},{"type":"suite:start","start":"2021-09-07T15:07:48.360Z","_duration":3269,"tests":[{"type":"test","start":"2021-09-07T15:07:48.361Z","_duration":2231,"uid":"test-00-0","cid":"0-2","title":"should show js single alert","fullTitle":"JavaScriptAlertPage.should show js single alert","output":[],"retries":0,"parent":"JavaScriptAlertPage","state":"passed","events":[],"errorIndex":0,"end":"2021-09-07T15:07:50.592Z"},{"type":"test","start":"2021-09-07T15:07:50.593Z","_duration":310,"uid":"test-00-1","cid":"0-2","title":"should cancel js confirm alert","fullTitle":"JavaScriptAlertPage.should cancel js confirm alert","output":[],"retries":0,"parent":"JavaScriptAlertPage","state":"passed","events":[],"errorIndex":0,"end":"2021-09-07T15:07:50.903Z"},{"type":"test","start":"2021-09-07T15:07:50.903Z","_duration":715,"uid":"test-00-2","cid":"0-2","title":"should display js prompt alert input","fullTitle":"JavaScriptAlertPage.should display js prompt alert input","output":[],"retries":0,"parent":"JavaScriptAlertPage","state":"passed","events":[],"errorIndex":0,"end":"2021-09-07T15:07:51.618Z"}],"hooks":[],"suites":[],"hooksAndTests":[{"type":"test","start":"2021-09-07T15:07:48.361Z","_duration":2231,"uid":"test-00-0","cid":"0-2","title":"should show js single alert","fullTitle":"JavaScriptAlertPage.should show js single alert","output":[{"method":"POST","endpoint":"/session/:sessionId/url","body":{"url":"https://the-internet.herokuapp.com/javascript_alerts"},"sessionId":"6e7ce0fb52932a0828ff66c43ffa1778","cid":"0-2","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/url","body":{"url":"https://the-internet.herokuapp.com/javascript_alerts"},"result":{"value":null},"sessionId":"6e7ce0fb52932a0828ff66c43ffa1778","cid":"0-2","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//button[@onclick=\"jsConfirm()\"]"},"sessionId":"6e7ce0fb52932a0828ff66c43ffa1778","cid":"0-2","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//button[@onclick=\"jsPrompt()\"]"},"sessionId":"6e7ce0fb52932a0828ff66c43ffa1778","cid":"0-2","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//button[@onclick=\"jsAlert()\"]"},"sessionId":"6e7ce0fb52932a0828ff66c43ffa1778","cid":"0-2","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//button[@onclick=\"jsConfirm()\"]"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"d799348b-ebb1-4dca-9078-bde5b9b2cee5"}},"sessionId":"6e7ce0fb52932a0828ff66c43ffa1778","cid":"0-2","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//button[@onclick=\"jsPrompt()\"]"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"45b19d25-6079-4fe4-8d13-e6aeb3f50190"}},"sessionId":"6e7ce0fb52932a0828ff66c43ffa1778","cid":"0-2","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//button[@onclick=\"jsAlert()\"]"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"150dd0ae-5b22-480d-831a-ac2bd8ac5731"}},"sessionId":"6e7ce0fb52932a0828ff66c43ffa1778","cid":"0-2","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"150dd0ae-5b22-480d-831a-ac2bd8ac5731","ELEMENT":"150dd0ae-5b22-480d-831a-ac2bd8ac5731"}]},"sessionId":"6e7ce0fb52932a0828ff66c43ffa1778","cid":"0-2","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"150dd0ae-5b22-480d-831a-ac2bd8ac5731","ELEMENT":"150dd0ae-5b22-480d-831a-ac2bd8ac5731"}]},"result":{"value":true},"sessionId":"6e7ce0fb52932a0828ff66c43ffa1778","cid":"0-2","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/150dd0ae-5b22-480d-831a-ac2bd8ac5731/click","body":{},"sessionId":"6e7ce0fb52932a0828ff66c43ffa1778","cid":"0-2","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/150dd0ae-5b22-480d-831a-ac2bd8ac5731/click","body":{},"result":{"value":null},"sessionId":"6e7ce0fb52932a0828ff66c43ffa1778","cid":"0-2","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/alert/text","body":{},"sessionId":"6e7ce0fb52932a0828ff66c43ffa1778","cid":"0-2","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/alert/text","body":{},"result":{"value":"I am a JS Alert"},"sessionId":"6e7ce0fb52932a0828ff66c43ffa1778","cid":"0-2","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/alert/accept","body":{},"sessionId":"6e7ce0fb52932a0828ff66c43ffa1778","cid":"0-2","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/alert/accept","body":{},"result":{"value":null},"sessionId":"6e7ce0fb52932a0828ff66c43ffa1778","cid":"0-2","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/alert","body":{},"sessionId":"6e7ce0fb52932a0828ff66c43ffa1778","cid":"0-2","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/alert","body":{},"result":{"value":false},"sessionId":"6e7ce0fb52932a0828ff66c43ffa1778","cid":"0-2","type":"result"}],"retries":0,"parent":"JavaScriptAlertPage","state":"passed","events":[],"errorIndex":0,"end":"2021-09-07T15:07:50.592Z"},{"type":"test","start":"2021-09-07T15:07:50.593Z","_duration":310,"uid":"test-00-1","cid":"0-2","title":"should cancel js confirm alert","fullTitle":"JavaScriptAlertPage.should cancel js confirm alert","output":[{"method":"POST","endpoint":"/session/:sessionId/url","body":{"url":"https://the-internet.herokuapp.com/javascript_alerts"},"sessionId":"6e7ce0fb52932a0828ff66c43ffa1778","cid":"0-2","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/url","body":{"url":"https://the-internet.herokuapp.com/javascript_alerts"},"result":{"value":null},"sessionId":"6e7ce0fb52932a0828ff66c43ffa1778","cid":"0-2","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//button[@onclick=\"jsConfirm()\"]"},"sessionId":"6e7ce0fb52932a0828ff66c43ffa1778","cid":"0-2","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//button[@onclick=\"jsPrompt()\"]"},"sessionId":"6e7ce0fb52932a0828ff66c43ffa1778","cid":"0-2","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//button[@onclick=\"jsAlert()\"]"},"sessionId":"6e7ce0fb52932a0828ff66c43ffa1778","cid":"0-2","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//button[@onclick=\"jsConfirm()\"]"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"63115afd-1b5d-4bb1-a59a-34fa4c9a3200"}},"sessionId":"6e7ce0fb52932a0828ff66c43ffa1778","cid":"0-2","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"63115afd-1b5d-4bb1-a59a-34fa4c9a3200","ELEMENT":"63115afd-1b5d-4bb1-a59a-34fa4c9a3200"}]},"sessionId":"6e7ce0fb52932a0828ff66c43ffa1778","cid":"0-2","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//button[@onclick=\"jsPrompt()\"]"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"0b97f7f0-7b40-49f2-b9c2-074667c0fbd9"}},"sessionId":"6e7ce0fb52932a0828ff66c43ffa1778","cid":"0-2","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//button[@onclick=\"jsAlert()\"]"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"c63acfe6-e02a-452f-aa55-bf7a593949e8"}},"sessionId":"6e7ce0fb52932a0828ff66c43ffa1778","cid":"0-2","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"63115afd-1b5d-4bb1-a59a-34fa4c9a3200","ELEMENT":"63115afd-1b5d-4bb1-a59a-34fa4c9a3200"}]},"result":{"value":true},"sessionId":"6e7ce0fb52932a0828ff66c43ffa1778","cid":"0-2","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/63115afd-1b5d-4bb1-a59a-34fa4c9a3200/click","body":{},"sessionId":"6e7ce0fb52932a0828ff66c43ffa1778","cid":"0-2","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/63115afd-1b5d-4bb1-a59a-34fa4c9a3200/click","body":{},"result":{"value":null},"sessionId":"6e7ce0fb52932a0828ff66c43ffa1778","cid":"0-2","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/alert/text","body":{},"sessionId":"6e7ce0fb52932a0828ff66c43ffa1778","cid":"0-2","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/alert/text","body":{},"result":{"value":"I am a JS Confirm"},"sessionId":"6e7ce0fb52932a0828ff66c43ffa1778","cid":"0-2","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/alert/dismiss","body":{},"sessionId":"6e7ce0fb52932a0828ff66c43ffa1778","cid":"0-2","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/alert/dismiss","body":{},"result":{"value":null},"sessionId":"6e7ce0fb52932a0828ff66c43ffa1778","cid":"0-2","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/alert","body":{},"sessionId":"6e7ce0fb52932a0828ff66c43ffa1778","cid":"0-2","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/alert","body":{},"result":{"value":false},"sessionId":"6e7ce0fb52932a0828ff66c43ffa1778","cid":"0-2","type":"result"}],"retries":0,"parent":"JavaScriptAlertPage","state":"passed","events":[],"errorIndex":0,"end":"2021-09-07T15:07:50.903Z"},{"type":"test","start":"2021-09-07T15:07:50.903Z","_duration":715,"uid":"test-00-2","cid":"0-2","title":"should display js prompt alert input","fullTitle":"JavaScriptAlertPage.should display js prompt alert input","output":[{"method":"POST","endpoint":"/session/:sessionId/url","body":{"url":"https://the-internet.herokuapp.com/javascript_alerts"},"sessionId":"6e7ce0fb52932a0828ff66c43ffa1778","cid":"0-2","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/url","body":{"url":"https://the-internet.herokuapp.com/javascript_alerts"},"result":{"value":null},"sessionId":"6e7ce0fb52932a0828ff66c43ffa1778","cid":"0-2","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//button[@onclick=\"jsConfirm()\"]"},"sessionId":"6e7ce0fb52932a0828ff66c43ffa1778","cid":"0-2","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//button[@onclick=\"jsPrompt()\"]"},"sessionId":"6e7ce0fb52932a0828ff66c43ffa1778","cid":"0-2","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//button[@onclick=\"jsAlert()\"]"},"sessionId":"6e7ce0fb52932a0828ff66c43ffa1778","cid":"0-2","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//button[@onclick=\"jsConfirm()\"]"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"eb2b1212-6f94-4eae-887d-0e51de707c1b"}},"sessionId":"6e7ce0fb52932a0828ff66c43ffa1778","cid":"0-2","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//button[@onclick=\"jsPrompt()\"]"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"ddbd89d3-d51b-4be3-9e4d-222ba45d5bc6"}},"sessionId":"6e7ce0fb52932a0828ff66c43ffa1778","cid":"0-2","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"ddbd89d3-d51b-4be3-9e4d-222ba45d5bc6","ELEMENT":"ddbd89d3-d51b-4be3-9e4d-222ba45d5bc6"}]},"sessionId":"6e7ce0fb52932a0828ff66c43ffa1778","cid":"0-2","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//button[@onclick=\"jsAlert()\"]"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"d5881f78-9e7c-4f83-a1e2-57b88bb8ed2c"}},"sessionId":"6e7ce0fb52932a0828ff66c43ffa1778","cid":"0-2","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"ddbd89d3-d51b-4be3-9e4d-222ba45d5bc6","ELEMENT":"ddbd89d3-d51b-4be3-9e4d-222ba45d5bc6"}]},"result":{"value":true},"sessionId":"6e7ce0fb52932a0828ff66c43ffa1778","cid":"0-2","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/ddbd89d3-d51b-4be3-9e4d-222ba45d5bc6/click","body":{},"sessionId":"6e7ce0fb52932a0828ff66c43ffa1778","cid":"0-2","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/ddbd89d3-d51b-4be3-9e4d-222ba45d5bc6/click","body":{},"result":{"value":null},"sessionId":"6e7ce0fb52932a0828ff66c43ffa1778","cid":"0-2","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/alert/text","body":{},"sessionId":"6e7ce0fb52932a0828ff66c43ffa1778","cid":"0-2","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/alert/text","body":{},"result":{"value":"I am a JS prompt"},"sessionId":"6e7ce0fb52932a0828ff66c43ffa1778","cid":"0-2","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/alert/text","body":{"text":"Hello World!"},"sessionId":"6e7ce0fb52932a0828ff66c43ffa1778","cid":"0-2","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/alert/text","body":{"text":"Hello World!"},"result":{"value":null},"sessionId":"6e7ce0fb52932a0828ff66c43ffa1778","cid":"0-2","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/alert/accept","body":{},"sessionId":"6e7ce0fb52932a0828ff66c43ffa1778","cid":"0-2","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/alert/accept","body":{},"result":{"value":null},"sessionId":"6e7ce0fb52932a0828ff66c43ffa1778","cid":"0-2","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#result"},"sessionId":"6e7ce0fb52932a0828ff66c43ffa1778","cid":"0-2","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#result"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"284a1c2d-2ff9-4bbf-aaf2-b71a5cd443dd"}},"sessionId":"6e7ce0fb52932a0828ff66c43ffa1778","cid":"0-2","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/284a1c2d-2ff9-4bbf-aaf2-b71a5cd443dd/text","body":{},"sessionId":"6e7ce0fb52932a0828ff66c43ffa1778","cid":"0-2","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/284a1c2d-2ff9-4bbf-aaf2-b71a5cd443dd/text","body":{},"result":{"value":"You entered: Hello World!"},"sessionId":"6e7ce0fb52932a0828ff66c43ffa1778","cid":"0-2","type":"result"},{"method":"DELETE","endpoint":"/session/:sessionId","body":{},"sessionId":"6e7ce0fb52932a0828ff66c43ffa1778","cid":"0-2","type":"command"},{"method":"DELETE","endpoint":"/session/:sessionId","body":{},"result":{"value":null},"sessionId":"6e7ce0fb52932a0828ff66c43ffa1778","cid":"0-2","type":"result"}],"retries":0,"parent":"JavaScriptAlertPage","state":"passed","events":[],"errorIndex":0,"end":"2021-09-07T15:07:51.618Z"}],"uid":"suite-0-0","cid":"0-2","file":"/Users/amiryamin/Desktop/projects/Mocha-WebdriverIO-Project/test/specs/test-js-alert.js","title":"JavaScriptAlertPage","fullTitle":"JavaScriptAlertPage","parent":"","end":"2021-09-07T15:07:51.629Z"},{"type":"suite:start","start":"2021-09-07T15:07:53.805Z","_duration":4208,"tests":[{"type":"test","start":"2021-09-07T15:07:53.806Z","_duration":2961,"uid":"test-00-0","cid":"0-3","title":"should allow user login secure area","fullTitle":"LoginPage.should allow user login secure area","output":[],"retries":0,"parent":"LoginPage","state":"passed","events":[],"errorIndex":0,"end":"2021-09-07T15:07:56.767Z"},{"type":"test","start":"2021-09-07T15:07:56.768Z","_duration":1232,"uid":"test-00-1","cid":"0-3","title":"should allow user logout","fullTitle":"LoginPage.should allow user logout","output":[],"retries":0,"parent":"LoginPage","state":"passed","events":[],"errorIndex":0,"end":"2021-09-07T15:07:58.000Z"}],"hooks":[],"suites":[],"hooksAndTests":[{"type":"test","start":"2021-09-07T15:07:53.806Z","_duration":2961,"uid":"test-00-0","cid":"0-3","title":"should allow user login secure area","fullTitle":"LoginPage.should allow user login secure area","output":[{"method":"POST","endpoint":"/session/:sessionId/url","body":{"url":"https://the-internet.herokuapp.com/login"},"sessionId":"8e6cf8e74666ee229516303506ccddb9","cid":"0-3","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/url","body":{"url":"https://the-internet.herokuapp.com/login"},"result":{"value":null},"sessionId":"8e6cf8e74666ee229516303506ccddb9","cid":"0-3","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#username"},"sessionId":"8e6cf8e74666ee229516303506ccddb9","cid":"0-3","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#username"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"1d5fcf0d-d1c2-4a83-8a43-e69a06acb6a1"}},"sessionId":"8e6cf8e74666ee229516303506ccddb9","cid":"0-3","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"1d5fcf0d-d1c2-4a83-8a43-e69a06acb6a1","ELEMENT":"1d5fcf0d-d1c2-4a83-8a43-e69a06acb6a1"}]},"sessionId":"8e6cf8e74666ee229516303506ccddb9","cid":"0-3","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"1d5fcf0d-d1c2-4a83-8a43-e69a06acb6a1","ELEMENT":"1d5fcf0d-d1c2-4a83-8a43-e69a06acb6a1"}]},"result":{"value":true},"sessionId":"8e6cf8e74666ee229516303506ccddb9","cid":"0-3","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#username"},"sessionId":"8e6cf8e74666ee229516303506ccddb9","cid":"0-3","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#username"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"1d5fcf0d-d1c2-4a83-8a43-e69a06acb6a1"}},"sessionId":"8e6cf8e74666ee229516303506ccddb9","cid":"0-3","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/1d5fcf0d-d1c2-4a83-8a43-e69a06acb6a1/clear","body":{},"sessionId":"8e6cf8e74666ee229516303506ccddb9","cid":"0-3","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/1d5fcf0d-d1c2-4a83-8a43-e69a06acb6a1/clear","body":{},"result":{"value":null},"sessionId":"8e6cf8e74666ee229516303506ccddb9","cid":"0-3","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/1d5fcf0d-d1c2-4a83-8a43-e69a06acb6a1/value","body":{"text":"tomsmith"},"sessionId":"8e6cf8e74666ee229516303506ccddb9","cid":"0-3","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/1d5fcf0d-d1c2-4a83-8a43-e69a06acb6a1/value","body":{"text":"tomsmith"},"result":{"value":null},"sessionId":"8e6cf8e74666ee229516303506ccddb9","cid":"0-3","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#password"},"sessionId":"8e6cf8e74666ee229516303506ccddb9","cid":"0-3","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#password"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"380e1ad3-4ec3-42ad-b900-2935f887914f"}},"sessionId":"8e6cf8e74666ee229516303506ccddb9","cid":"0-3","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/380e1ad3-4ec3-42ad-b900-2935f887914f/clear","body":{},"sessionId":"8e6cf8e74666ee229516303506ccddb9","cid":"0-3","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/380e1ad3-4ec3-42ad-b900-2935f887914f/clear","body":{},"result":{"value":null},"sessionId":"8e6cf8e74666ee229516303506ccddb9","cid":"0-3","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/380e1ad3-4ec3-42ad-b900-2935f887914f/value","body":{"text":"SuperSecretPassword!"},"sessionId":"8e6cf8e74666ee229516303506ccddb9","cid":"0-3","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/380e1ad3-4ec3-42ad-b900-2935f887914f/value","body":{"text":"SuperSecretPassword!"},"result":{"value":null},"sessionId":"8e6cf8e74666ee229516303506ccddb9","cid":"0-3","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"button[type=\"submit\"]"},"sessionId":"8e6cf8e74666ee229516303506ccddb9","cid":"0-3","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"button[type=\"submit\"]"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"5c23d30d-b2cf-4003-a378-4ace1f3ba231"}},"sessionId":"8e6cf8e74666ee229516303506ccddb9","cid":"0-3","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"5c23d30d-b2cf-4003-a378-4ace1f3ba231","ELEMENT":"5c23d30d-b2cf-4003-a378-4ace1f3ba231"}]},"sessionId":"8e6cf8e74666ee229516303506ccddb9","cid":"0-3","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"5c23d30d-b2cf-4003-a378-4ace1f3ba231","ELEMENT":"5c23d30d-b2cf-4003-a378-4ace1f3ba231"}]},"result":{"value":true},"sessionId":"8e6cf8e74666ee229516303506ccddb9","cid":"0-3","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"button[type=\"submit\"]"},"sessionId":"8e6cf8e74666ee229516303506ccddb9","cid":"0-3","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"button[type=\"submit\"]"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"5c23d30d-b2cf-4003-a378-4ace1f3ba231"}},"sessionId":"8e6cf8e74666ee229516303506ccddb9","cid":"0-3","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/5c23d30d-b2cf-4003-a378-4ace1f3ba231/click","body":{},"sessionId":"8e6cf8e74666ee229516303506ccddb9","cid":"0-3","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/5c23d30d-b2cf-4003-a378-4ace1f3ba231/click","body":{},"result":{"value":null},"sessionId":"8e6cf8e74666ee229516303506ccddb9","cid":"0-3","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#flash"},"sessionId":"8e6cf8e74666ee229516303506ccddb9","cid":"0-3","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#flash"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"752d4b4a-7c30-4d1a-a0e0-bae6f9732449"}},"sessionId":"8e6cf8e74666ee229516303506ccddb9","cid":"0-3","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":"#flash"},"sessionId":"8e6cf8e74666ee229516303506ccddb9","cid":"0-3","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":"#flash"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"752d4b4a-7c30-4d1a-a0e0-bae6f9732449"}]},"sessionId":"8e6cf8e74666ee229516303506ccddb9","cid":"0-3","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#flash"},"sessionId":"8e6cf8e74666ee229516303506ccddb9","cid":"0-3","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#flash"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"752d4b4a-7c30-4d1a-a0e0-bae6f9732449"}},"sessionId":"8e6cf8e74666ee229516303506ccddb9","cid":"0-3","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/752d4b4a-7c30-4d1a-a0e0-bae6f9732449/text","body":{},"sessionId":"8e6cf8e74666ee229516303506ccddb9","cid":"0-3","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/752d4b4a-7c30-4d1a-a0e0-bae6f9732449/text","body":{},"result":{"value":"You logged into a secure area!\n×"},"sessionId":"8e6cf8e74666ee229516303506ccddb9","cid":"0-3","type":"result"}],"retries":0,"parent":"LoginPage","state":"passed","events":[],"errorIndex":0,"end":"2021-09-07T15:07:56.767Z"},{"type":"test","start":"2021-09-07T15:07:56.768Z","_duration":1232,"uid":"test-00-1","cid":"0-3","title":"should allow user logout","fullTitle":"LoginPage.should allow user logout","output":[{"method":"POST","endpoint":"/session/:sessionId/url","body":{"url":"https://the-internet.herokuapp.com/login"},"sessionId":"8e6cf8e74666ee229516303506ccddb9","cid":"0-3","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/url","body":{"url":"https://the-internet.herokuapp.com/login"},"result":{"value":null},"sessionId":"8e6cf8e74666ee229516303506ccddb9","cid":"0-3","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#username"},"sessionId":"8e6cf8e74666ee229516303506ccddb9","cid":"0-3","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#username"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"ba9f5ac2-2cbf-40b4-ab44-2e041c4176d7"}},"sessionId":"8e6cf8e74666ee229516303506ccddb9","cid":"0-3","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"ba9f5ac2-2cbf-40b4-ab44-2e041c4176d7","ELEMENT":"ba9f5ac2-2cbf-40b4-ab44-2e041c4176d7"}]},"sessionId":"8e6cf8e74666ee229516303506ccddb9","cid":"0-3","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"ba9f5ac2-2cbf-40b4-ab44-2e041c4176d7","ELEMENT":"ba9f5ac2-2cbf-40b4-ab44-2e041c4176d7"}]},"result":{"value":true},"sessionId":"8e6cf8e74666ee229516303506ccddb9","cid":"0-3","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#username"},"sessionId":"8e6cf8e74666ee229516303506ccddb9","cid":"0-3","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#username"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"ba9f5ac2-2cbf-40b4-ab44-2e041c4176d7"}},"sessionId":"8e6cf8e74666ee229516303506ccddb9","cid":"0-3","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/ba9f5ac2-2cbf-40b4-ab44-2e041c4176d7/clear","body":{},"sessionId":"8e6cf8e74666ee229516303506ccddb9","cid":"0-3","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/ba9f5ac2-2cbf-40b4-ab44-2e041c4176d7/clear","body":{},"result":{"value":null},"sessionId":"8e6cf8e74666ee229516303506ccddb9","cid":"0-3","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/ba9f5ac2-2cbf-40b4-ab44-2e041c4176d7/value","body":{"text":"tomsmith"},"sessionId":"8e6cf8e74666ee229516303506ccddb9","cid":"0-3","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/ba9f5ac2-2cbf-40b4-ab44-2e041c4176d7/value","body":{"text":"tomsmith"},"result":{"value":null},"sessionId":"8e6cf8e74666ee229516303506ccddb9","cid":"0-3","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#password"},"sessionId":"8e6cf8e74666ee229516303506ccddb9","cid":"0-3","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#password"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"c7d4ff41-815c-47f9-a481-ac1cbcf9e156"}},"sessionId":"8e6cf8e74666ee229516303506ccddb9","cid":"0-3","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/c7d4ff41-815c-47f9-a481-ac1cbcf9e156/clear","body":{},"sessionId":"8e6cf8e74666ee229516303506ccddb9","cid":"0-3","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/c7d4ff41-815c-47f9-a481-ac1cbcf9e156/clear","body":{},"result":{"value":null},"sessionId":"8e6cf8e74666ee229516303506ccddb9","cid":"0-3","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/c7d4ff41-815c-47f9-a481-ac1cbcf9e156/value","body":{"text":"SuperSecretPassword!"},"sessionId":"8e6cf8e74666ee229516303506ccddb9","cid":"0-3","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/c7d4ff41-815c-47f9-a481-ac1cbcf9e156/value","body":{"text":"SuperSecretPassword!"},"result":{"value":null},"sessionId":"8e6cf8e74666ee229516303506ccddb9","cid":"0-3","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"button[type=\"submit\"]"},"sessionId":"8e6cf8e74666ee229516303506ccddb9","cid":"0-3","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"button[type=\"submit\"]"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"b6aa93e0-c9a0-485c-9bbc-586ef449c7e2"}},"sessionId":"8e6cf8e74666ee229516303506ccddb9","cid":"0-3","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"b6aa93e0-c9a0-485c-9bbc-586ef449c7e2","ELEMENT":"b6aa93e0-c9a0-485c-9bbc-586ef449c7e2"}]},"sessionId":"8e6cf8e74666ee229516303506ccddb9","cid":"0-3","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"b6aa93e0-c9a0-485c-9bbc-586ef449c7e2","ELEMENT":"b6aa93e0-c9a0-485c-9bbc-586ef449c7e2"}]},"result":{"value":true},"sessionId":"8e6cf8e74666ee229516303506ccddb9","cid":"0-3","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"button[type=\"submit\"]"},"sessionId":"8e6cf8e74666ee229516303506ccddb9","cid":"0-3","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"button[type=\"submit\"]"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"b6aa93e0-c9a0-485c-9bbc-586ef449c7e2"}},"sessionId":"8e6cf8e74666ee229516303506ccddb9","cid":"0-3","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/b6aa93e0-c9a0-485c-9bbc-586ef449c7e2/click","body":{},"sessionId":"8e6cf8e74666ee229516303506ccddb9","cid":"0-3","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/b6aa93e0-c9a0-485c-9bbc-586ef449c7e2/click","body":{},"result":{"value":null},"sessionId":"8e6cf8e74666ee229516303506ccddb9","cid":"0-3","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#flash"},"sessionId":"8e6cf8e74666ee229516303506ccddb9","cid":"0-3","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#flash"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"42cca605-1c8e-4002-9b86-a5ccfa7ed86f"}},"sessionId":"8e6cf8e74666ee229516303506ccddb9","cid":"0-3","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":"#flash"},"sessionId":"8e6cf8e74666ee229516303506ccddb9","cid":"0-3","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":"#flash"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"42cca605-1c8e-4002-9b86-a5ccfa7ed86f"}]},"sessionId":"8e6cf8e74666ee229516303506ccddb9","cid":"0-3","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#flash"},"sessionId":"8e6cf8e74666ee229516303506ccddb9","cid":"0-3","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#flash"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"42cca605-1c8e-4002-9b86-a5ccfa7ed86f"}},"sessionId":"8e6cf8e74666ee229516303506ccddb9","cid":"0-3","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/42cca605-1c8e-4002-9b86-a5ccfa7ed86f/text","body":{},"sessionId":"8e6cf8e74666ee229516303506ccddb9","cid":"0-3","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/42cca605-1c8e-4002-9b86-a5ccfa7ed86f/text","body":{},"result":{"value":"You logged into a secure area!\n×"},"sessionId":"8e6cf8e74666ee229516303506ccddb9","cid":"0-3","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//a[@href=\"/logout\"]"},"sessionId":"8e6cf8e74666ee229516303506ccddb9","cid":"0-3","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//a[@href=\"/logout\"]"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"3c3a2630-d687-426a-b13f-35a1da4b3e8b"}},"sessionId":"8e6cf8e74666ee229516303506ccddb9","cid":"0-3","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"3c3a2630-d687-426a-b13f-35a1da4b3e8b","ELEMENT":"3c3a2630-d687-426a-b13f-35a1da4b3e8b"}]},"sessionId":"8e6cf8e74666ee229516303506ccddb9","cid":"0-3","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"3c3a2630-d687-426a-b13f-35a1da4b3e8b","ELEMENT":"3c3a2630-d687-426a-b13f-35a1da4b3e8b"}]},"result":{"value":true},"sessionId":"8e6cf8e74666ee229516303506ccddb9","cid":"0-3","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//a[@href=\"/logout\"]"},"sessionId":"8e6cf8e74666ee229516303506ccddb9","cid":"0-3","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//a[@href=\"/logout\"]"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"3c3a2630-d687-426a-b13f-35a1da4b3e8b"}},"sessionId":"8e6cf8e74666ee229516303506ccddb9","cid":"0-3","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/3c3a2630-d687-426a-b13f-35a1da4b3e8b/click","body":{},"sessionId":"8e6cf8e74666ee229516303506ccddb9","cid":"0-3","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/3c3a2630-d687-426a-b13f-35a1da4b3e8b/click","body":{},"result":{"value":null},"sessionId":"8e6cf8e74666ee229516303506ccddb9","cid":"0-3","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#flash"},"sessionId":"8e6cf8e74666ee229516303506ccddb9","cid":"0-3","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#flash"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"b8e60fea-6e2d-456b-9233-8a6da3f81105"}},"sessionId":"8e6cf8e74666ee229516303506ccddb9","cid":"0-3","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":"#flash"},"sessionId":"8e6cf8e74666ee229516303506ccddb9","cid":"0-3","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":"#flash"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"b8e60fea-6e2d-456b-9233-8a6da3f81105"}]},"sessionId":"8e6cf8e74666ee229516303506ccddb9","cid":"0-3","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#flash"},"sessionId":"8e6cf8e74666ee229516303506ccddb9","cid":"0-3","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#flash"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"b8e60fea-6e2d-456b-9233-8a6da3f81105"}},"sessionId":"8e6cf8e74666ee229516303506ccddb9","cid":"0-3","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/b8e60fea-6e2d-456b-9233-8a6da3f81105/text","body":{},"sessionId":"8e6cf8e74666ee229516303506ccddb9","cid":"0-3","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/b8e60fea-6e2d-456b-9233-8a6da3f81105/text","body":{},"result":{"value":"You logged out of the secure area!\n×"},"sessionId":"8e6cf8e74666ee229516303506ccddb9","cid":"0-3","type":"result"}],"retries":0,"parent":"LoginPage","state":"passed","events":[],"errorIndex":0,"end":"2021-09-07T15:07:58.000Z"}],"uid":"suite-0-0","cid":"0-3","file":"/Users/amiryamin/Desktop/projects/Mocha-WebdriverIO-Project/test/specs/test-login.js","title":"LoginPage","fullTitle":"LoginPage","parent":"","end":"2021-09-07T15:07:58.013Z"},{"type":"suite:start","start":"2021-09-07T15:07:58.014Z","_duration":404,"tests":[{"type":"test","start":"2021-09-07T15:07:58.014Z","_duration":402,"uid":"test-01-0","cid":"0-3","title":"should not allow guests to reach secure page","fullTitle":"SecurePage.should not allow guests to reach secure page","output":[],"retries":0,"parent":"SecurePage","state":"passed","events":[],"errorIndex":0,"end":"2021-09-07T15:07:58.416Z"}],"hooks":[],"suites":[],"hooksAndTests":[{"type":"test","start":"2021-09-07T15:07:58.014Z","_duration":402,"uid":"test-01-0","cid":"0-3","title":"should not allow guests to reach secure page","fullTitle":"SecurePage.should not allow guests to reach secure page","output":[{"method":"POST","endpoint":"/session/:sessionId/url","body":{"url":"https://the-internet.herokuapp.com/secure"},"sessionId":"8e6cf8e74666ee229516303506ccddb9","cid":"0-3","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/url","body":{"url":"https://the-internet.herokuapp.com/secure"},"result":{"value":null},"sessionId":"8e6cf8e74666ee229516303506ccddb9","cid":"0-3","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"sessionId":"8e6cf8e74666ee229516303506ccddb9","cid":"0-3","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"result":{"value":"https://the-internet.herokuapp.com/login"},"sessionId":"8e6cf8e74666ee229516303506ccddb9","cid":"0-3","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#flash"},"sessionId":"8e6cf8e74666ee229516303506ccddb9","cid":"0-3","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#flash"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"d8c5ad8f-d9dc-4e1f-b50a-6c2b379bd104"}},"sessionId":"8e6cf8e74666ee229516303506ccddb9","cid":"0-3","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":"#flash"},"sessionId":"8e6cf8e74666ee229516303506ccddb9","cid":"0-3","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":"#flash"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"d8c5ad8f-d9dc-4e1f-b50a-6c2b379bd104"}]},"sessionId":"8e6cf8e74666ee229516303506ccddb9","cid":"0-3","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#flash"},"sessionId":"8e6cf8e74666ee229516303506ccddb9","cid":"0-3","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#flash"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"d8c5ad8f-d9dc-4e1f-b50a-6c2b379bd104"}},"sessionId":"8e6cf8e74666ee229516303506ccddb9","cid":"0-3","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/d8c5ad8f-d9dc-4e1f-b50a-6c2b379bd104/text","body":{},"sessionId":"8e6cf8e74666ee229516303506ccddb9","cid":"0-3","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/d8c5ad8f-d9dc-4e1f-b50a-6c2b379bd104/text","body":{},"result":{"value":"You must login to view the secure area!\n×"},"sessionId":"8e6cf8e74666ee229516303506ccddb9","cid":"0-3","type":"result"},{"method":"DELETE","endpoint":"/session/:sessionId","body":{},"sessionId":"8e6cf8e74666ee229516303506ccddb9","cid":"0-3","type":"command"},{"method":"DELETE","endpoint":"/session/:sessionId","body":{},"result":{"value":null},"sessionId":"8e6cf8e74666ee229516303506ccddb9","cid":"0-3","type":"result"}],"retries":0,"parent":"SecurePage","state":"passed","events":[],"errorIndex":0,"end":"2021-09-07T15:07:58.416Z"}],"uid":"suite-0-1","cid":"0-3","file":"/Users/amiryamin/Desktop/projects/Mocha-WebdriverIO-Project/test/specs/test-login.js","title":"SecurePage","fullTitle":"SecurePage","parent":"","end":"2021-09-07T15:07:58.418Z"}],"reportFile":"/Users/amiryamin/Desktop/projects/Mocha-WebdriverIO-Project/reports/html-reports/master-report.html"}